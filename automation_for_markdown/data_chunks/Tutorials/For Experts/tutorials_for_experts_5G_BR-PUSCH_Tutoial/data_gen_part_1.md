# 5G NR PUSCH Tutorial<a class="headerlink" href="https://nvlabs.github.io/sionna/examples/5G_NR_PUSCH.html#5G-NR-PUSCH-Tutorial" title="Permalink to this headline"></a>
    
This notebook provides an introduction to Sionna’s <a class="reference external" href="https://nvlabs.github.io/sionna/api/nr.html">5G New Radio (NR) module</a> and, in particular, the <a class="reference external" href="https://nvlabs.github.io/sionna/api/nr.html#pusch">physical uplink shared channel (PUSCH)</a>. This module provides implementations of a small subset of the physical layer functionalities as described in the 3GPP specifications <a class="reference external" href="https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=3213">38.211</a>,
<a class="reference external" href="https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=3214">38.212</a> and <a class="reference external" href="https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=3216">38.214</a>.
    
You will
 
- Get an understanding of the different components of a PUSCH configuration, such as the carrier, DMRS, and transport block,
- Learn how to rapidly simulate PUSCH transmissions for multiple transmitters,
- Modify the PUSCHReceiver to use a custom MIMO Detector.
# Table of Content
## GPU Configuration and Imports
## A Hello World Example
## Carrier Configuration
  
  

## GPU Configuration and Imports<a class="headerlink" href="https://nvlabs.github.io/sionna/examples/5G_NR_PUSCH.html#GPU-Configuration-and-Imports" title="Permalink to this headline"></a>

```python
[1]:
```

```python
import os
gpu_num = 0 # Use "" to use the CPU
os.environ["CUDA_VISIBLE_DEVICES"] = f"{gpu_num}"
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
# Import Sionna
try:
    import sionna
except ImportError as e:
    # Install Sionna if package is not already installed
    import os
    os.system("pip install sionna")
    import sionna
# Load the required Sionna components
from sionna.nr import PUSCHConfig, PUSCHTransmitter, PUSCHReceiver
from sionna.channel import AWGN, RayleighBlockFading, OFDMChannel, TimeChannel, time_lag_discrete_time_channel
from sionna.channel.tr38901 import AntennaArray, UMi, UMa, RMa
from sionna.channel import gen_single_sector_topology as gen_topology
from sionna.utils import compute_ber, ebnodb2no, sim_ber
from sionna.ofdm import KBestDetector, LinearDetector
from sionna.mimo import StreamManagement
```
```python
[2]:
```

```python
%matplotlib inline
import matplotlib.pyplot as plt
import numpy as np
import time
```
```python
[3]:
```

```python
import tensorflow as tf
# Configure the notebook to use only a single GPU and allocate only as much memory as needed
# For more details, see https://www.tensorflow.org/guide/gpu
gpus = tf.config.list_physical_devices('GPU')
if gpus:
    try:
        tf.config.experimental.set_memory_growth(gpus[0], True)
    except RuntimeError as e:
        print(e)
# Avoid warnings from TensorFlow
tf.get_logger().setLevel('ERROR')
```

## A Hello World Example<a class="headerlink" href="https://nvlabs.github.io/sionna/examples/5G_NR_PUSCH.html#A-Hello-World-Example" title="Permalink to this headline"></a>
    
Let us start with a simple “Hello, World!” example in which we will simulate PUSCH transmissions from a single transmitter to a single receiver over an AWGN channel.

```python
[4]:
```

```python
# Create a PUSCH configuration with default settings
pusch_config = PUSCHConfig()
# Instantiate a PUSCHTransmitter from the PUSCHConfig
pusch_transmitter = PUSCHTransmitter(pusch_config)
# Create a PUSCHReceiver using the PUSCHTransmitter
pusch_receiver = PUSCHReceiver(pusch_transmitter)
# AWGN channel
channel = AWGN()
# Simulate transmissions over the AWGN channel
batch_size = 16
no = 0.1 # Noise variance
x, b = pusch_transmitter(batch_size) # Generate transmit signal and info bits
y = channel([x, no]) # Simulate channel output
b_hat = pusch_receiver([x, no]) # Recover the info bits
# Compute BER
print("BER:", compute_ber(b, b_hat).numpy())
```


```python
BER: 0.0
```

    
Although the above code snippet seems rather simple, you have actually carried out standard-compliant simulations of the NR PUSCH!
    
To better understand what is actually going on under the hood, we can inspect the OFDM resource grid that is generated by the transmitter with the following command:

```python
[5]:
```

```python
pusch_transmitter.resource_grid.show();
```


    
The above figure tells us that we are simulating a slot of 14 OFDM symbols spanning 48 subcarriers, which correspond to four physical resource blocks (PRBs) in 5G terminology. The third OFDM symbol is reserved for pilot transmissions, so-called demodulation reference signals (DMRS), and the rest is used for data.

## Carrier Configuration<a class="headerlink" href="https://nvlabs.github.io/sionna/examples/5G_NR_PUSCH.html#Carrier-Configuration" title="Permalink to this headline"></a>
    
When you create a PUSCHConfig instance, it automatically creates a CarrierConfig instance with default settings. You can inspect this configuration with the following command:

```python
[6]:
```

```python
pusch_config.carrier.show()
```


```python
Carrier Configuration
=====================
cyclic_prefix : normal
cyclic_prefix_length : 5.208333333333334e-06
frame_duration : 0.01
frame_number : 0
kappa : 64.0
mu : 0
n_cell_id : 1
n_size_grid : 4
n_start_grid : 0
num_slots_per_frame : 10
num_slots_per_subframe : 1
num_symbols_per_slot : 14
slot_number : 0
sub_frame_duration : 0.001
subcarrier_spacing : 15
t_c : 5.086263020833334e-10
t_s : 3.2552083333333335e-08

```

    
Most of these parameters cannot be controlled as they are simply derived from others. For example, the cyclic prefix length depends on the subcarrier spacing. Let us see what happens, when we choose larger subcarrier spacing:

```python
[7]:
```

```python
pusch_config.carrier.subcarrier_spacing = 60
pusch_config.carrier.show()
```


```python
Carrier Configuration
=====================
cyclic_prefix : normal
cyclic_prefix_length : 1.6927083333333335e-06
frame_duration : 0.01
frame_number : 0
kappa : 64.0
mu : 2
n_cell_id : 1
n_size_grid : 4
n_start_grid : 0
num_slots_per_frame : 40
num_slots_per_subframe : 4
num_symbols_per_slot : 14
slot_number : 0
sub_frame_duration : 0.001
subcarrier_spacing : 60
t_c : 5.086263020833334e-10
t_s : 3.2552083333333335e-08

```

    
The cyclic prefix has shrunk from $5.2 \mu s$ to $1.69 \mu s$ and the number of slots per frame has increased from $10$ to $40$.
    
If we change to the extended cyclic prefix, the number of OFDM symbols per slot will decrease from 14 to 12.

```python
[8]:
```

```python
pusch_config_ext = pusch_config.clone()
pusch_config_ext.carrier.cyclic_prefix = "extended"
pusch_config_ext.carrier.show()
```


```python
Carrier Configuration
=====================
cyclic_prefix : extended
cyclic_prefix_length : 4.166666666666667e-06
frame_duration : 0.01
frame_number : 0
kappa : 64.0
mu : 2
n_cell_id : 1
n_size_grid : 4
n_start_grid : 0
num_slots_per_frame : 40
num_slots_per_subframe : 4
num_symbols_per_slot : 12
slot_number : 0
sub_frame_duration : 0.001
subcarrier_spacing : 60
t_c : 5.086263020833334e-10
t_s : 3.2552083333333335e-08

```

    
Please have a look at the API documentation of <a class="reference external" href="https://nvlabs.github.io/sionna/api/nr.html#sionna.nr.CarrierConfig">PUSCHCarrierConfig</a> for more detail.

