[5, "INSTRUCTION: Initialize the environment for using Sionna by setting up the GPU configuration and suppressing TensorFlow warnings. Include the necessary imports for Sionna, TensorFlow, NumPy, and plotting capabilities.\n\nINSTRUCTION: Demonstrate how to check the NVIDIA GPU status using an appropriate bash command in a Jupyter notebook environment.\n\nINSTRUCTION: Explain the concept of batching in Sionna simulations and how it achieves parallelization by using the first tensor dimension.\n\nINSTRUCTION: List Sionna's design principles for maintaining efficient dataflow, specifying the data types used for signal-processing components and models, and mention how components can be reused.\n\nINSTRUCTION: Differentiate between eager mode and graph mode in TensorFlow when developing with Sionna, and mention the option for XLA acceleration.\n\nINSTRUCTION: Describe how auto-grad is used to support automatic differentiability in Sionna and why this feature is advantageous for deep learning workflows.\n\nINSTRUCTION: Provide guidance on how Sionna's code is organized into sub-packages for different tasks, and refer to the API documentation for further details."]
[2, "INSTRUCTION: Explain how to simulate a lumped amplification optical channel using the Sionna Python package.\n\nINSTRUCTION: Describe the process of setting up the simulation environment, including configuring the GPU and importing necessary modules like `os`, `tensorflow`, `numpy`, and `matplotlib`.\n\nINSTRUCTION: Explain how to generate a single Gaussian impulse for transmission over an optical channel, including defining simulation and impulse parameters.\n\nINSTRUCTION: Discuss the significance of the fiber span length, amplifier gain, and noise figure when setting up an optical channel with lumped amplification.\n\nINSTRUCTION: Provide guidance on creating and configuring a fiber span without nonlinearity and chromatic dispersion using Sionna's `SSFM` class.\n\nINSTRUCTION: Demonstrate how to instantiate an Erbium Doped Fiber Amplifier (EDFA) using Sionna's `EDFA` class with specified gain and noise figure.\n\nINSTRUCTION: Illustrate how to create a lumped amplification channel function that simulates transmission through multiple fiber spans and EDFAs.\n\nINSTRUCTION: Describe the process of transmitting an impulse through the optical channel and visualizing the input and output optical signals in both time and frequency domains.\n\nINSTRUCTION: Conclude by explaining how to interpret the visualized data to assess the impact of attenuation and the noise introduced by the EDFAs on the transmitted optical signal."]
[12, "INSTRUCTION: Explain the purpose of using the \"sionna\" package for differentiable communication systems and its relevance to modern communication system design.\n\nINSTRUCTION: Detail the steps necessary to set up the Python environment for running Sionna, including the importation of necessary libraries and the configuration to avoid TensorFlow warnings.\n\nINSTRUCTION: Describe the process to check if Sionna is installed and how to install it if not present within a Python environment.\n\nINSTRUCTION: Provide a step-by-step guide to setting up a training loop for an end-to-end communication system model using the Sionna package with TensorFlow.\n\nINSTRUCTION: Outline the role of the stochastic gradient descent (SGD) steps in the training of communication systems using Sionna.\n\nINSTRUCTION: Illustrate how to perform forward passes within a training loop and calculate the gradients using TensorFlow's gradient tape mechanism.\n\nINSTRUCTION: Explain how to apply gradients to model weights during training with Sionna and the role of optimizers such as Adam.\n\nINSTRUCTION: Demonstrate how to save trained model weights with the 'pickle' module in Python after completing the training loop.\n\nINSTRUCTION: Teach how to load previously saved model weights into a Sionna end-to-end system model for evaluation purposes.\n\nINSTRUCTION: Describe how to simulate and evaluate the performance of a trained end-to-end communication system using Sionna, including how to plot bit error rate (BER) graphs and interpret the results.\n\nINSTRUCTION: Provide an example of how to analyze the evaluation output table of a trained Sionna model to assess its performance at various signal-to-noise ratio (SNR) levels."]
[8, "INSTRUCTION: Explain the purpose of setting the \"CUDA_VISIBLE_DEVICES\" environment variable and its impact on TensorFlow's GPU usage.\n\nINSTRUCTION: Describe the steps to install the Sionna package in case it is not already installed, as outlined in the Imports & Basics section.\n\nINSTRUCTION: Explain how to confirm the GPU setup using the `nvidia-smi` command in a Jupyter notebook.\n\nINSTRUCTION: State what is meant by accessing Sionna functions within the `sn` namespace after importing Sionna.\n\nINSTRUCTION: Demonstrate how to encode input bits using Sionna's 5G compliant LDPC encoder.\n\nINSTRUCTION: Write and run a Python code snippet using Sionna to encode a batch of random input bits and print the output codewords.\n\nINSTRUCTION: Present an example code snippet to illustrate batch-processing with Sionna and explain the concept using dimensions for users and base stations.\n\nINSTRUCTION: Show how to create a new encoder instance for codewords of a different length in Sionna and how to link the corresponding decoder.\n\nINSTRUCTION: Outline the process of encoding random bits and print the shape of the input and output tensors as well as the total number of processed bits.\n\nINSTRUCTION: Write a brief comparison between LDPC codes and Polar codes as used in Sionna for error correction, and how to replace LDPC code with Polar code.\n\nINSTRUCTION: Explain how Sionna's `Model` class can be extended to create a custom-coded system for an AWGN channel incorporating FEC.\n\nINSTRUCTION: Write a Python script using Sionna to simulate a coded communication system over an AWGN channel and display the bit error rate (BER) performance using the provided model and `BerPlot`.\n\nINSTRUCTION: Interpret the BER performance simulation output and determine the next action based on whether the target block errors have been reached or if no error has occurred.\n\nINSTRUCTION: Provide guidance on how to switch from an LDPC coding scheme to a Polar or convolutional coding scheme in the provided `CodedSystemAWGN` class and adjust the simulation accordingly."]
[0, "INSTRUCTION: How do I set up my Python environment to use a specific GPU or the CPU when working with the Sionna package?\n\nINSTRUCTION: Provide steps to install the Sionna package in Python if it's not already installed.\n\nINSTRUCTION: Describe the process for configuring TensorFlow to use only a single GPU and allocate memory dynamically.\n\nINSTRUCTION: List the Python imports required for running basic MIMO simulations using the Sionna package.\n\nINSTRUCTION: Define the variables needed to simulate a simple uncoded transmission with 16QAM modulation in Sionna.\n\nINSTRUCTION: Demonstrate how to generate a batch of random transmit vectors with the QAMSource class in Sionna.\n\nINSTRUCTION: Explain how to create an instance of the FlatFadingChannel class with i.i.d Rayleigh fading and AWGN, and how to ensure the output includes channel realizations.\n\nINSTRUCTION: Show how to use the lmmse_equalizer function in Sionna to compute soft symbols using perfect channel knowledge.\n\nINSTRUCTION: Illustrate how to plot transmitted versus received constellations after equalization in a Sionna simulation using matplotlib.\n\nINSTRUCTION: Describe the method to estimate the effective noise variance after equalization and confirm it by comparing to the mean-squared error.\n\nINSTRUCTION: Explain how to make hard decisions on the received symbols and compute the Symbol Error Rate (SER) in Sionna.\n\nINSTRUCTION: Guide on how to add spatial correlation to the channel using the SpatialCorrelation and KroneckerModel classes in Sionna.\n\nINSTRUCTION: Walk through the process of validating the applied spatial correlation by computing empirical covariance matrices from a large batch of channel realizations in Sionna.\n\nINSTRUCTION: Compare the Symbol Error Rate (SER) before and after adding spatial correlation to the channel to understand its impact in a Sionna simulation.\n\nINSTRUCTION: Prompt the user to experiment with different levels of spatial correlation by adjusting the exponential correlation matrix parameters and observe the effects on SER in Sionna."]
[1, "INSTRUCTION: Explain how to set up a simple flat-fading MIMO transmission simulation using the Sionna Python package.\n\nINSTRUCTION: Describe the steps to use the FastFadingChannel class within the Sionna package.\n\nINSTRUCTION: Provide a step-by-step guide on applying spatial antenna correlation in MIMO system simulations with Sionna.\n\nINSTRUCTION: Illustrate how to implement LMMSE detection with perfect channel knowledge using the Sionna package.\n\nINSTRUCTION: Detail the process to run Bit Error Rate (BER) and Symbol Error Rate (SER) simulations in Sionna for MIMO systems.\n\nINSTRUCTION: Outline how to configure a GPU with TensorFlow to run Sionna simulations and import necessary modules.\n\nINSTRUCTION: Show how to install the Sionna package if it is not already installed in the Python environment.\n\nINSTRUCTION: Demonstrate how to extend uncoded symbol transmissions to coded BER simulations using Sionna's LDPC5GEncoder and LDPC5GDecoder.\n\nINSTRUCTION: Explain how to generate random QAM symbols by mapping coded bits and how to reshape the data into the required format for transmission in Sionna.\n\nINSTRUCTION: Describe the process of transmitting symbols over a channel and equalizing them using the lmmse_equalizer function in Sionna.\n\nINSTRUCTION: Explain how to demap received symbols to Log-Likelihood Ratios (LLRs) and decode them using the functionalities provided by Sionna.\n\nINSTRUCTION: Guide on running BER simulations using a Keras model integrated with Sionna's functionalities for a MIMO system.\n\nINSTRUCTION: Provide instructions on how to use the `@tf.function(jit_compile=True)` decorator to speed up simulations in TensorFlow for Sionna models.\n\nINSTRUCTION: Detail the steps to enable Sionna's xla_compat feature for executing a Keras model with TensorFlow operations.\n\nINSTRUCTION: Explain how to instantiate a Keras model with different channel conditions, such as uncorrelated channels and spatially correlated channels using the Kronecker model in Sionna.\n\nINSTRUCTION: Show how to use the PlotBER class for Monte-Carlo simulations and how to interpret the simulation results provided by the Sionna package."]
[13, "INSTRUCTION: Explain the function of the 'StreamManagement' object in Sionna for MIMO simulations.\n\nINSTRUCTION: Demonstrate how to set up a 'StreamManagement' object for a SIMO link in Sionna, with a single UT and a BS equipped with multiple antennas.\n\nINSTRUCTION: Describe how to define the number of streams per transmitter in Sionna and create an RX-TX association matrix.\n\nINSTRUCTION: Illustrate the process of configuring the OFDM 'ResourceGrid' in Sionna, covering the importance of parameters like the number of OFDM symbols, FFT size, and cyclic prefix length.\n\nINSTRUCTION: Run Sionna code to initialize an OFDM 'ResourceGrid' with a specified number of OFDM symbols, FFT size, subcarrier spacing, and a cyclic prefix, then visualize the grid.\n\nINSTRUCTION: Display and explain the automatically generated 'PilotPattern' associated with the 'ResourceGrid' in Sionna.\n\nINSTRUCTION: Demonstrate how to change pilot patterns and other parameters in the 'ResourceGrid' and observe their impact on the resulting resource grid.\n\nINSTRUCTION: Explain the purpose of antenna arrays in the context of Sionna simulations when using advanced channel models.\n\nINSTRUCTION: Write Sionna code to configure and visualize the antenna arrays for a UT with a single-polarized antenna and a BS with a dual cross-polarized antenna array.\n\nINSTRUCTION: Describe how to customize and visualize different antenna patterns, polarizations, and array geometries in Sionna.\n\nINSTRUCTION: Outline the steps for setting up a channel model in Sionna and discuss the differences between CDL, TDL, UMi, UMa, and RMa models.\n\nINSTRUCTION: Implement a CDL channel model in Sionna, specifying the delay spread, carrier frequency, antenna arrays, and the direction of transmission.\n\nINSTRUCTION: Generate path gains and delays using a CDL channel model in Sionna, specifying batch size and the number of time steps based on the OFDM symbol duration.\n\nINSTRUCTION: Extract and print the shapes of the 'a' and 'tau' arrays from the path gains and delays generated by the CDL channel model in Sionna.\n\nINSTRUCTION: Plot a channel impulse response realization and the time evolution of a path gain using the path gains and delays from the CDL channel model.\n\nINSTRUCTION: Locate and refer to Sionna documentation and other resourceful notebooks for examples on advanced simulations and multi-user MIMO configurations."]
[11, "INSTRUCTION: What is the purpose and key content of the \"Differentiable Communication Systems\" section in the Sionna tutorial Part II?\n\nINSTRUCTION: How do I import and set up the Sionna package and other required libraries in my Python environment to start working with differentiable communication systems?\n\nINSTRUCTION: Describe the process of creating custom trainable layers using Keras, as demonstrated in Sionna Part II tutorial.\n\nINSTRUCTION: Construct a `NeuralDemapper` class as a custom Keras layer, following the code example from the Sionna tutorial. Explain each step and method in the class, along with their purpose.\n\nINSTRUCTION: Illustrate how to build an end-to-end communication system using Sionna by creating an `End2EndSystem` class that incorporates a custom neural demapper layer.\n\nINSTRUCTION: Detail the functionality of the `End2EndSystem` class, including its components and what the `__call__` method does during both training and evaluation.\n\nINSTRUCTION: Write a brief overview explaining the training and performance benchmarking process for the end-to-end system featuring the neural demapper versus a conventional demapper baseline, as provided in the tutorial.\n\nINSTRUCTION: Use the provided baseline and untrained model benchmarking code to plot BER curves. Explain each parameter set in the `simulate` function and the expected outcomes of the simulation.\n\nINSTRUCTION: Examine the output table from the simulation and deduce what conclusions can be made regarding the performance of the untrained end-to-end system compared to the conventional baseline."]
[9, "INSTRUCTION: Explain how to set up a Python environment for Sionna and import necessary libraries and modules.\n\nINSTRUCTION: Provide a step-by-step guide on installing the Sionna package using pip, if it is not already installed.\n\nINSTRUCTION: Demonstrate how to check whether a GPU is available using the `nvidia-smi` command and the `%matplotlib inline` magic command for plotting.\n\nINSTRUCTION: Describe the difference between eager and graph execution modes in TensorFlow, and why it's beneficial to switch to graph mode when using Sionna.\n\nINSTRUCTION: Show how to enable graph mode in a TensorFlow function using the `@tf.function` decorator.\n\nINSTRUCTION: Give an example of a simple TensorFlow function that runs in graph mode and explain how to trace and call this function with different batch sizes and SNR values (dB).\n\nINSTRUCTION: Illustrate how to use input tensors with the graph-mode function to minimize re-tracing and improve performance.\n\nINSTRUCTION: Provide a code snippet that allows users to view cached signatures of a TensorFlow function in graph mode.\n\nINSTRUCTION: Teach how to compare throughput of eager mode vs graph mode using time measurement and the TensorFlow function in graph mode.\n\nINSTRUCTION: Explain how to simulate link-level performance with different Eb/No values in graph mode and plot the resulting bit error rate, utilizing the Sionna functions for BER assessment.\n\nINSTRUCTION: Introduce the concept of XLA compilation with TensorFlow and compare it to graph mode execution without XLA, including enabling it with `@tf.function(jit_compile=True)`.\n\nINSTRUCTION: Give a brief explanation on how to check GPU usage and performance with the `!nvidia-smi` command and how to tune batch sizes for optimizing throughput.\n\nINSTRUCTION: Create an exercise to simulate the coded bit error rate (BER) for a Polar coded and 64-QAM modulation system, explaining how to set the codeword length and the code rate in Sionna, and mentioning the differences between SC and SCL decoding strategies."]
[4, "INSTRUCTION: Describe how to initiate a Python notebook to simulate an optical channel with lumped amplification using the Sionna package, focusing on Erbium Doped Fiber Amplifiers (EDFA) and standard single-mode fiber (S-SMF).\n\nINSTRUCTION: Summarize the assumptions made regarding the transmitter and receiver components within the optical channel simulation using Sionna.\n\nINSTRUCTION: Explain the split-step Fourier method (SSFM) and why it is required for simulating the optical channel with amplified spontaneous emission (ASE) noise, chromatic dispersion (CD), and Kerr nonlinearity.\n\nINSTRUCTION: Demonstrate in Sionna how to configure a channel model that simulates fiber spans and lumped optical amplification with adjustable parameters like amplifier gain, noise figure, and SSFM simulation steps.\n\nINSTRUCTION: Provide an example of the Python code for calculating and compiling the lumped amplification channel model using the Sionna package with the `tf.function` decorator.\n\nINSTRUCTION: Illustrate how to simulate the transmission of a Gaussian impulse over the channel model, capturing ASE noise, CD, and Kerr nonlinearity effects.\n\nINSTRUCTION: Show how to visualize the transmitted and received signal in both the time and frequency domains using the matplotlib library in Python.\n\nINSTRUCTION: Discuss the implications of the observation that the spectrum of the received signal is compressed and contradicts the expected spectral broadening due to Kerr nonlinearity, indicating the joint effects of CD and Kerr nonlinearity.\n\nINSTRUCTION: Explain the importance of Solitons in the context of the optical channel and how the Gaussian input impulse is transformed into a higher-order Soliton during propagation.\n\nINSTRUCTION: List the provided reference by Ren\u00e9-Jean Essiambre et al. as a fundamental resource for understanding the capacity limits of optical fiber networks and direct the user to reference this material for more in-depth study."]
[3, "INSTRUCTION: Demonstrate how to simulate the transmission of a single Gaussian impulse over a lumped amplification channel model using the Sionna package and include the configuration of a standard single-mode fiber with multiple spans and Erbium Doped Fiber Amplifiers (EDFA).\n\nINSTRUCTION: Explain the representation of the amplifier gain (G) and the noise figure (F) of each EDFA in the context of the Sionna package.\n\nINSTRUCTION: Identify the simplifying assumptions made in the Sionna simulation, such as idealized transmitter components and the neglect of certain receiver-side noise effects.\n\nINSTRUCTION: Guide through the process of progressively enabling channel impairments in the Sionna simulation, starting with attenuation, to better understand their impact on the optical signal.\n\nINSTRUCTION: Show how to configure the Sionna simulation to investigate the effect of chromatic dispersion (CD) on an optical signal by setting the group velocity dispersion (GVD) parameter $\\beta_2$ and disabling noise.\n\nINSTRUCTION: Illustrate the transmission of a Gaussian impulse through a fiber span with chromatic dispersion enabled, using the Sionna package, and compare the received signal's spectrum and phase with that of the transmitted impulse.\n\nINSTRUCTION: Describe how to configure the Kerr nonlinearity effect in the Sionna package by setting the nonlinearity coefficient $\\gamma$ and disabling previous impairments for clarity.\n\nINSTRUCTION: Instruct how to transmit a Gaussian impulse over a fiber with only Kerr nonlinearity activated in Sionna and analyze the changes in signal phase and spectrum, relating the findings to the impulse's peak power.\n\nINSTRUCTION: Provide insights into how the (isolated) Kerr nonlinearity impacts the phase of the optical signal without affecting its amplitude using visuals generated by Sionna's plotting capabilities.\n\nINSTRUCTION: Offer a hint on the effect of increasing the peak power $p_0$ of the transmitted impulse on the impact of Kerr nonlinearity in a Sionna simulation.\n\nThese instructions aim to facilitate a comprehensive understanding of how to simulate and analyze optical channels with lumped amplification using the Sionna package for Python, covering key phenomena such as chromatic dispersion and Kerr nonlinearity."]
[15, "INSTRUCTION: Explain how to set the GPU or CPU for training a model using the Sionna package.\n\nINSTRUCTION: Identify the steps necessary to install the Sionna package in a Python environment in case it is not already installed.\n\nINSTRUCTION: Describe the process to import the necessary libraries and dependencies for working with the Sionna package.\n\nINSTRUCTION: Show how to define and set simulation parameters for a Sionna-based communication system simulation.\n\nINSTRUCTION: Elucidate the method to allocate Simulation Parameters like the number of bits per symbol, Eb/N0 range, batch size, and code rate in Sionna.\n\nINSTRUCTION: Demonstrate how to define the number of user terminals (UT) and base stations (BS), including their antenna configurations in a Sionna-based system.\n\nINSTRUCTION: Provide instructions to create and interpret the RX-TX association matrix for stream management in a point-to-point communication link using Sionna.\n\nINSTRUCTION: Guide on setting up the Resource Grid parameters specifically for an OFDM-based communication system with Sionna.\n\nINSTRUCTION: Explain how to define antenna configurations for both user terminal and base station using the Sionna package.\n\nINSTRUCTION: Describe the steps to configure a channel model, like the CDL model, including its parameters like delay spread, direction, model type, and UT speed within the Sionna framework."]
[19, "INSTRUCTION: Import the necessary modules for setting up a GPU configuration and verify if TensorFlow is utilizing the GPU correctly, addressing potential memory growth issues.\n\nINSTRUCTION: Install the Sionna package if it is not already present, handling any import errors that may arise during the process.\n\nINSTRUCTION: Configure the Python environment to display matplotlib plot outputs inline within the notebook interface.\n\nINSTRUCTION: Import the classes and functions from the Sionna package required for pulse shaping, such as QAMSource, Upsampling, Downsampling, RootRaisedCosineFilter, and functions for computing the empirical power spectral density (PSD) and adjacent channel leakage power ratio (ACLR).\n\nINSTRUCTION: Explain the concept of windowing and its impact on the spectral properties of truncated filters, covering the relationship between the physical length of filters and real-valued window vectors.\n\nINSTRUCTION: Create a RootRaisedCosineFilter with specific span-in-symbols and samples-per-symbol, and compare the impulse and magnitude responses, as well as ACLR, with and without the use of a Blackman window.\n\nINSTRUCTION: Use the matplotlib library to visualize the impulse response and magnitude response of the RootRaisedCosineFilter both with and without windowing.\n\nINSTRUCTION: Calculate and print the ACLR values in decibels for filters with and without windowing, demonstrating the effect of windowing on out-of-band attenuation and passband broadening."]
[10, "INSTRUCTION: Write Python code to import the Sionna package and check for its installation or install it if not present.\n\nINSTRUCTION: Explain how to limit GPU memory usage and how to avoid TensorFlow warnings while using Sionna.\n\nINSTRUCTION: Summarize the procedure for setting up a simple communication system to transmit bits modulated as QAM symbols over an AWGN channel using Sionna, and specify how to make the constellation trainable.\n\nINSTRUCTION: Write Python code to simulate forward passes through a communication system with a trainable constellation and an AWGN channel in Sionna, including batch size preparation and noise calculation.\n\nINSTRUCTION: Describe how to visualize the input and output of a communication channel in Sionna with a plot.\n\nINSTRUCTION: Outline the steps required to perform stochastic gradient descent (SGD) to optimize a trainable parameter within the Sionna framework, and give a Python code example for computing the gradient using `GradientTape`.\n\nINSTRUCTION: Provide the Python code for calculating binary cross-entropy (BCE) as a loss function using Sionna and TensorFlow, incorporating the logit outputs from a demapper.\n\nINSTRUCTION: Detail the method to apply gradients to trainable weights using an optimizer in Sionna and provide a Python code example using the Adam optimizer.\n\nINSTRUCTION: Illustrate how to compare and visualize the changes in a constellation before and after applying a gradient step in Sionna, using plotting functionality.\n\nINSTRUCTION: Describe the iterative process of SGD for training a communication system in Sionna and discuss best practices to determine when to stop training."]
[7, "INSTRUCTION: Explain how you would start using the Sionna Python package for simulating communication systems.\n\nINSTRUCTION: Discuss the contents of the four tutorial notebooks provided by the Sionna tutorial and state their respective focuses.\n\nINSTRUCTION: Show the steps required to check if Sionna is installed and demonstrate how to install it if necessary.\n\nINSTRUCTION: Describe how to set up an environment to use a specific GPU or CPU for computations with Sionna.\n\nINSTRUCTION: Provide a code example for how to import necessary libraries such as TensorFlow, NumPy, and Sionna, and configure the environment to suppress TensorFlow warnings.\n\nINSTRUCTION: Define running bash commands in Jupyter notebooks and give an example using a common device monitoring command.\n\nINSTRUCTION: Write an explanation of why it is convenient to wrap Sionna-based communication systems into Keras models.\n\nINSTRUCTION: Demonstrate how to use the Keras functional API to build a simple communication system model with Sionna.\n\nINSTRUCTION: Construct the `__init__()` and `__call()__` functions for a 'UncodedSystemAWGN' class in Sionna, detailing the purpose and parameters of each method.\n\nINSTRUCTION: Show an example of instantiating the 'UncodedSystemAWGN' model with specific parameters for the number of bits per symbol and block length.\n\nINSTRUCTION: Explain how to simulate the bit error rate (BER) for a communication system model using Sionna, and provide a code snippet to plot BER curves over a range of Eb/N0 values.\n\nINSTRUCTION: Interpret the output table of a BER simulation, understanding what each column represents, such as 'EbNo [dB]', 'BER', 'runtime [s]', and 'status'.\n\nINSTRUCTION: Discuss how to add additional simulations to existing BER plots and what block errors and bit errors refer to in the context of Sionna simulations."]
[16, "INSTRUCTION: Explain the primary objective of Part IV of the Sionna tutorial and identify the key steps outlined for achieving this objective.\n\nINSTRUCTION: Describe the process of setting up the working environment for using the Sionna package in Python, as indicated in the imports section of Part IV.\n\nINSTRUCTION: List the imported libraries and packages required for implementing an advanced neural receiver as per the Sionna tutorial.\n\nINSTRUCTION: Summarize the role of the 'ResidualBlock' and 'NeuralReceiver' classes in Sionna's neural receiver implementation and outline how they are constructed.\n\nINSTRUCTION: What are residual (skip) connections and how are they used in the context of implementing a neural receiver in Sionna?\n\nINSTRUCTION: Describe how to implement the 'NeuralReceiver' class with TensorFlow Keras layers for processing a 2D resource grid.\n\nINSTRUCTION: Explain the importance of binary cross-entropy as a loss function for a neural receiver, detailing how it applies to the binary classification problems in resource elements.\n\nINSTRUCTION: Provide a step-by-step guide on how to define an end-to-end communication system with a neural receiver in Sionna, explaining the roles of the different components in the model.\n\nINSTRUCTION: Differentiate between the 'training' and 'evaluating' modes while instantiating the OFDMSystemNeuralReceiver model and explain how each mode affects the computation of the loss or the system's output.\n\nINSTRUCTION: Discuss the significance of the loss function in the context of training a neural receiver and why logits are suitable for binary cross-entropy without additional processing.\n\nINSTRUCTION: Explain how to create a training loop for the neural receiver in Sionna, detailing the steps from sampling SNRs to saving the model weights after training.\n\nINSTRUCTION: Highlight the reason for using the TensorFlow function decorator '@tf.function' in the `__call__` method of the OFDMSystemNeuralReceiver class and its effect on training performance.\n\nINSTRUCTION: Describe the procedure for saving trained model weights to a file in Sionna and outline the purpose of using 'pickle' for this task."]
[14, "INSTRUCTION: Explain the core functionalities and goals of Sionna's Part III: Advanced Link-level Simulations tutorial.\n\nINSTRUCTION: Describe the structure and purpose of the four notebooks that make up the Sionna tutorial series.\n\nINSTRUCTION: Where can one find the official Sionna documentation and what kind of information does it provide?\n\nINSTRUCTION: Detail the steps needed to set up the Sionna package in a Python environment, including handling GPUs and suppressing TensorFlow warnings.\n\nINSTRUCTION: Summarize the process of importing necessary libraries and modules for working with Sionna, including modules for plotting and TensorFlow Keras models.\n\nINSTRUCTION: Explain the difference between simulating a channel in the frequency domain and the time domain with Sionna, specifically mentioning 'OFDMChannel' and 'TimeChannel' layers.\n\nINSTRUCTION: Create a step-by-step guide to initialize constants, sources, encoders, mappers, and channels for a frequency domain uplink transmission simulation.\n\nINSTRUCTION: Write out the process to run a transmission simulation in Sionna, and how to inspect the shape of the layer outputs at each stage using Python print statements.\n\nINSTRUCTION: Illustrate how to convert $E_b/N_0$ from dB to noise power spectral density in the context of a Sionna simulation.\n\nINSTRUCTION: Describe how to implement the OFDMSystem class as a Keras model, including conditions for using either least squares (LS) estimation or perfect channel state information (CSI).\n\nINSTRUCTION: Explain how to simulate the OFDMSystem model with both LS estimation and perfect CSI over a range of $E_b/N_0$ values to plot BER curves.\n\nINSTRUCTION: Provide guidance on reading and interpreting the output table of the BER simulation, including understanding the significance of columns like 'BER', 'BLER', 'runtime [s]', and 'status'."]
[17, "INSTRUCTION: Explain how to set up the Sionna package for Python and import essential libraries for creating a communication system simulation.\n\nINSTRUCTION: Show how to enable GPU usage in a Python script for machine learning with Sionna and TensorFlow.\n\nINSTRUCTION: Provide the steps to install the Sionna package in Python if it is not already installed.\n\nINSTRUCTION: Describe the process of importing TensorFlow, NumPy, and other necessary libraries for building a simulation model in Sionna.\n\nINSTRUCTION: Outline the code to create an OFDM system class inheriting from TensorFlow's Keras Model in Sionna.\n\nINSTRUCTION: Summarize how to define a neural receiver for an OFDM system using custom trainable layers in Sionna.\n\nINSTRUCTION: Illustrate how to run a Monte-Carlo simulation to benchmark the performance of the OFDM system against different baselines.\n\nINSTRUCTION: Elaborate on how to instantiate a model with a neural receiver in Sionna and load pre-trained weights.\n\nINSTRUCTION: Explain how to evaluate the bit error rate (BER) and block error rate (BLER) of an OFDM system equipped with a neural receiver in Sionna.\n\nINSTRUCTION: Guide through the procedure of using the Sionna's built-in utilities to plot the BER performance curves of different receiver configurations.\n\nINSTRUCTION: Provide instructions on using the 'pip' command to install the Sionna package for training communication systems.\n\nINSTRUCTION: Discuss the benefits of Sionna, such as ease of scaling to multi-GPU simulations and the availability of TensorBoard debugging.\n\nINSTRUCTION: Encourage learners to experiment with extending the Sionna project, emphasizing the open-source nature and potential for customization.\n\nINSTRUCTION: Point out further educational resources like the official Sionna documentation and additional tutorials for comprehensive learning.\n\nINSTRUCTION: Prompt exploration of the referenced papers to understand the research context and advancements underlying the design of neural receivers in Sionna."]
[18, "INSTRUCTION: Demonstrate how to configure a GPU environment in Python for Sionna, including memory management and setting environment variables to control GPU visibility and TensorFlow logging levels.\n\nINSTRUCTION: Import the necessary modules in Python for pulse shaping using the Sionna package, including matplotlib for plotting, numpy for numerical operations, and specific signal processing and QAM source utilities from Sionna.\n\nINSTRUCTION: Explain how to create a RootRaisedCosineFilter object in Sionna with a specific roll-off factor, span in symbols, and oversampling factor.\n\nINSTRUCTION: Illustrate how to use the RootRaisedCosineFilter's visualization functions to display its impulse response and magnitude response in both logarithmic (dB) and linear scales, normalized by symbol time and bandwidth.\n\nINSTRUCTION: Verify the length of a Sionna filter object and explain why the filter length in Sionna is always an odd number, even when the product of span_in_symbols and samples_per_symbol could be even.\n\nINSTRUCTION: Describe the process of upsampling a sequence of QAM symbols in Sionna, including configuring the QAM source layer, inserting zeros after every QAM symbol, and applying the RootRaisedCosineFilter to the upsampled sequence.\n\nINSTRUCTION: Show how to recover QAM symbols from a waveform by applying matched filtering followed by downsampling in Sionna, specifying the peak value index calculation, creating the Downsampling layer, and plotting the signals at various stages for visualization.\n\nINSTRUCTION: Present the method to calculate and plot the mean-squared error (MSE) between transmitted and recovered QAM symbols in Sionna, and discuss how changes in the filter's span in symbols or roll-off factor influence the MSE.\n\nINSTRUCTION: Describe how to visualize the empirical power spectral density (PSD) of a transmitted signal in Sionna and explain what it represents with regards to in-band and out-of-band energy.\n\nINSTRUCTION: Calculate the adjacent channel leakage power ratio (ACLR) empirically in Sionna, discuss its significance for waveform metrics, and compare the empirical ACLR with the theoretical ACLR provided as a property of a Sionna filter object.\n\nINSTRUCTION: Modify the roll-off factor in the creation of a RootRaisedCosineFilter to improve the ACLR and demonstrate the difference in the resulting ACLR value."]
[6, "INSTRUCTION: Review the Sionna tutorial to understand the flow of building a point-to-point link with a 5G NR compliant code and a 3GPP channel model.\n\nINSTRUCTION: Read the official documentation of the Sionna package to comprehend its usage and component implementation.\n\nINSTRUCTION: Implement the basic Python import statements necessary for running simulations with Sionna.\n\nINSTRUCTION: Learn how to set up the computing environment to use GPUs or the CPU for processing Sionna simulations.\n\nINSTRUCTION: Practice running bash commands within Jupyter notebooks, such as checking the NVIDIA GPU status.\n\nINSTRUCTION: Understand the steps to create and visualize a QAM constellation using Sionna's Constellation class, adjusting modulation orders as needed.\n\nINSTRUCTION: Get familiar with the process of setting up a mapper and demapper for symbol transmission using Sionna's Mapper and Demapper classes.\n\nINSTRUCTION: Use the API documentation to explore the properties and methods of Sionna classes like `Mapper`.\n\nINSTRUCTION: Integrate Keras functional API concepts by stacking Sionna layers in model building.\n\nINSTRUCTION: Simulate bitstream generation using Sionna's BinarySource utility.\n\nINSTRUCTION: Set up and understand the usage of the AWGN channel model in Sionna for simulation.\n\nINSTRUCTION: Use Sionna's utility functions to calculate noise power spectral density ratios for communication simulations.\n\nINSTRUCTION: Explore the tensor shapes at each stage of the communication link pipeline, from bit generation to symbol demapping.\n\nINSTRUCTION: Use Eager mode to access and print the tensor values for a given number of samples, aiding in the debugging process.\n\nINSTRUCTION: Visualize the channel output for different SNRs to comprehend the noise impact on received signals in Sionna simulations.\n\nINSTRUCTION: Compare LLR distributions produced by different demapping strategies in Sionna, referring to relevant examples such as the Bit-Interleaved Coded Modulation notebook."]
