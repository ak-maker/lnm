## Here is to insert the answer back to the context

# 要插入的字符串
insert_text = "To begin a basic link-level simulation using the Sionna Python package, take the following steps, which integrate Keras layers for system complexity, as demonstrated in the given context:\n\n1. Define the system parameters including the lengths of the LDPC codewords, the number of information bits, the code rate, and the number of bits per symbol for modulation. These parameters guide the subsequent layer configurations in the simulation.\n\n```python\nn_ldpc = 500 # LDPC codeword length\nk_ldpc = 250 # number of info bits per LDPC codeword\ncoderate = k_ldpc / n_ldpc\nnum_bits_per_symbol = 4 # number of bits mapped to one symbol (cf. QAM)\n```\n\n2. Choose the algorithm options for the demapper and the LDPC belief propagation (BP) decoder. This allows you to specify the method used for computations within these components.\n\n```python\ndemapping_method = \"app\" # try \"max-log\"\nldpc_cn_type = \"boxplus\" # try also \"minsum\"\n```\n\n3. Initialize the required components (layers) with the given system parameters, including the binary source, encoder, mapper, channel, demapper, and decoder. The components are modeled as Keras layers to encapsulate the complexity of their respective tasks.\n\n```python\nbinary_source = sionna.utils.BinarySource()\nencoder = sionna.fec.ldpc.encoding.LDPC5GEncoder(k_ldpc, n_ldpc)\nconstellation = sionna.mapping.Constellation(\"qam\", num_bits_per_symbol)\nmapper = sionna.mapping.Mapper(constellation=constellation)\nchannel = sionna.channel.AWGN()\ndemapper = sionna.mapping.Demapper(demapping_method,\n                                   constellation=constellation)\ndecoder = sionna.fec.ldpc.decoding.LDPC5GDecoder(encoder,\n                                                 hard_out=True, cn_type=ldpc_cn_type,\n                                                 num_iter=20)\n```\n\n4. Run the simulation in eager mode. This is beneficial for prototyping, as it enables on-the-fly adjustments, such as varying batch size or signal-to-noise ratio (SNR) during the simulation.\n\n5. Set the simulation parameters, generate random bit vectors, and simulate each step of the communication process:\n\n   - Encoding the bits using an LDPC code.\n   - Mapping the coded bits to constellation symbols.\n   - Transmitting over an AWGN channel.\n   - Demapping the received symbols to log-likelihood ratios (LLRs).\n   - Decoding the LLRs using the LDPC decoder.\n\nIn the code provided in the context, a batch processing approach is used, and specifies a batch size and the SNR level.\n\n```python\nbatch_size = 1000\nebno_db = 4\n```\n\nThen, the simulation is executed step-by-step, processing a batch of random bits through encoding, mapping, channel transmission, and demapping, followed by decoding.\n\n```python\nb = binary_source([batch_size, k_ldpc])\nc = encoder(b)\nx = mapper(c)\nno = sionna.utils.ebnodb2no(ebno_db, num_bits_per_symbol, coderate)\ny = channel([x, no])\nllr = demapper([y, no])\nb_hat = decoder(llr)\n```\n\n6. After all bits are processed, compute the bit error rates (BER) before and after decoding to evaluate the system's performance.\n\n```python\nc_hat = tf.cast(tf.less(0.0, llr), tf.float32) # hard-decided bits before dec.\nber_uncoded = sionna.utils.metrics.compute_ber(c, c_hat)\nber_coded = sionna.utils.metrics.compute_ber(b, b_hat)\nprint(\"BER uncoded = {:.3f} at EbNo = {:.1f} dB\".format(ber_uncoded, ebno_db))\nprint(\"BER after decoding = {:.3f} at EbNo = {:.1f} dB\".format(ber_coded, ebno_db))\n```\n\n7. The simulation output provides the BER results, which help to assess the link-level transmission quality under the specified SNR conditions.\n\nBy following these steps, the Sionna Python package allows for efficient simulation of the physical layer (PHY) of a communication system, factoring in detailed aspects such as modulation, channel characteristics, and error correction, all while utilizing the power of Keras layers to manage system complexity."
# 特定行号，例如5表示文件的第5行
line_number = 2

# 打开文件，读取内容
with open("E:\python\lnm\\automation_for_markdown\data_chunks\Discover Sionna\discover_sionna\IA_data_gen_part_2.md", 'r', encoding='utf-8') as file:
    lines = file.readlines()

# 在特定行的ANSWER:后面插入字符串
# 因为列表索引从0开始，所以要用行号减去1
if 'ANSWER:' in lines[line_number - 1]:
    part1, part2 = lines[line_number - 1].split('ANSWER:', 1)
    lines[line_number - 1] = part1 + 'ANSWER:' + insert_text + part2

# 将修改后的内容写回到文件中
with open('your_file.txt', 'w') as file:
    file.writelines(lines)
