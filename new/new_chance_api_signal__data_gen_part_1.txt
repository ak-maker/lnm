INSTRUCTION: Explain how to create and apply a SincFilter using Sionna to a batch of QPSK baseband symbols.
ANSWER:To create and apply a SincFilter using Sionna to a batch of QPSK baseband symbols, you would follow these steps:

1. **Create a batch of QPSK baseband symbols:**
   To generate a sequence of QPSK symbols, you would typically use a QPSK source. Here, it is assumed that you already have generated the baseband symbols and stored them in a variable (perhaps in a similar way as with `QAMSource` for QAM symbols in the given context). Let's say the variable name is `qpsk_symbols`.

```python
# Assuming qpsk_symbols is a Tensor with shape [batch_size, num_symbols]
```

2. **Define parameters for your sinc filter:**
   Decide the parameters for the sinc filter, including the span in symbols, samples per symbol, and an optional window function.

```python
span_in_symbols = 10  # As an example, you can choose an appropriate value
samples_per_symbol = 4  # This could be different, aligned with the oversampling in your system
```

3. **Create the SincFilter:**
   Instantiating the sinc filter with the chosen parameters. If you need a window function, select from the available options ("hann", "hamming", "blackman"), or set it to `None` if no window is desired.

```python
# No windowing is used here; for windowing, replace None with "hann", "hamming", or "blackman".
sinc_filter = sionna.signal.SincFilter(span_in_symbols, samples_per_symbol, window=None, normalize=True)
```

4. **Upsample the QPSK symbols:**
   Before filtering, you must upsample the baseband symbols, as sinc (ideal low-pass) filtering is typically done at a higher sampling rate. Use the Upsampling layer for this:

```python
# Create instance of the Upsampling layer
us = sionna.signal.Upsampling(samples_per_symbol)

# Upsample the baseband symbols
qpsk_symbols_upsampled = us(qpsk_symbols)
```

5. **Filter the upsampled symbols:**
   Once the symbols are upsampled, apply the sinc filter to the signals.

```python
# Filter the upsampled sequence with the sinc filter
qpsk_symbols_filtered = sinc_filter(qpsk_symbols_upsampled)
```

6. **Downsample the filtered symbols (if needed):**
   After filtering, if you want to return to the original sampling rate, you need to downsample the signals.

```python
# Instantiate a downsampling layer
ds = sionna.signal.Downsampling(samples_per_symbol, sinc_filter.length-1, num_symbols)

# Downsample the filtered signals
qpsk_symbols_downsampled = ds(qpsk_symbols_filtered)
```

Please note that the snippets provided in the context, including QAMSource, are meant to serve as a guideline for generating baseband symbols and filtering them. For QPSK, you would replace the QAM-specific portions with appropriate QPSK symbol generation code.

This is a simplified example to illustrate the steps for creating and applying a SincFilter to a batch of QPSK symbols using Sionna. Depending on the specific use case and signal processing requirements, additional steps or modifications might be required.

INSTRUCTION: Describe how to initialize a RaisedCosineFilter with a given span, samples per symbol, beta, and apply it to a random signal.
ANSWER:To initialize a `RaisedCosineFilter` with a given span, samples per symbol, beta, and apply it to a random signal, you can follow these steps:

```python
import tensorflow as tf
import numpy as np
from sionna.signal import RaisedCosineFilter, Upsampling

# Given parameters
span_in_symbols = 10  # Example span of the filter in symbols
samples_per_symbol = 4  # Example number of samples per symbol (oversampling rate)
beta = 0.25  # Example roll-off factor

# Initialize the RaisedCosineFilter with the given parameters.
rc_filter = RaisedCosineFilter(span_in_symbols, samples_per_symbol, beta)

# Generate a random signal to apply the filter to.
# For example, creating a batch of random sequences with a specific size.
batch_size = 1          # Example batch size (single sequence in this case)
num_symbols = 100       # Example number of symbols in the sequence

# Generate random complex-valued samples.
# The values should be normally distributed to represent a typical random signal.
random_signal = tf.complex(np.random.normal(size=(batch_size, num_symbols)),
                           np.random.normal(size=(batch_size, num_symbols)))

# Upsample the random signal if necessary using the Upsampling layer.
# This is required if the 'samples_per_symbol' parameter is greater than 1.
upsampler = Upsampling(samples_per_symbol)
random_signal_upsampled = upsampler(random_signal)

# Apply the RaisedCosineFilter to the upsampled random signal.
filtered_signal = rc_filter(random_signal_upsampled)

# The 'filtered_signal' now contains the random signal after being shaped by the Raised Cosine filter.
```

Make sure to replace the example values of `span_in_symbols`, `samples_per_symbol`, `beta`, `batch_size`, and `num_symbols` with the actual values you need for your application.

The `random_signal` is a placeholder for any input signal you would like to filter. In practical systems, the input would be a stream of symbols rather than random noise.

Note: The `Upsampling` layer is used here as it is often customary to upsample the signal before applying a pulse shaping filter to avoid aliasing. The shaping filter is then applied in the higher sample rate domain, and if needed, the signal would be downsampled later on in the processing chain.

