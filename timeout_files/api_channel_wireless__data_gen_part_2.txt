# Wireless

## Flat-fading channel
### class: sionna.channel.KroneckerModel(r_tx=None, r_rx=None)
### class: sionna.channel.PerColumnModel(r_rx)
## Channel model interface
## class: sionna.channel.ChannelModel
## Time domain channel
### class: sionna.channel.TimeChannel(channel_model, bandwidth, num_time_samples, maximum_delay_spread=3e-6, l_min=None, l_max=None, normalize_channel=False, add_awgn=True, return_channel=False, dtype=tf.complex64, **kwargs)
### class: sionna.channel.GenerateTimeChannel(channel_model, bandwidth, num_time_samples, l_min, l_max, normalize_channel=False)

# Wireless

This module provides layers and functions that implement wireless channel models. Models currently available include AWGN, flat-fading with (optional) SpatialCorrelation, RayleighBlockFading, as well as models from the 3rd Generation Partnership Project (3GPP) [TR38901]: TDL, CDL, UMi, UMa, and RMa. It is also possible to use externally generated CIRs.

Apart from flat-fading, all of these models generate channel impulse responses (CIRs) that can then be used to implement a channel transfer function in the time domain or assuming an OFDM waveform.

This is achieved using the different functions, classes, and Keras layers which operate as shown in the figures below.

Fig. 7 Channel module architecture for time domain simulations.

Fig. 8 Channel module architecture for simulations assuming OFDM waveform.

A channel model generate CIRs from which channel responses in the time domain or in the frequency domain are computed using the cir_to_time_channel() or cir_to_ofdm_channel() functions, respectively. If one does not need access to the raw CIRs, the GenerateTimeChannel and GenerateOFDMChannel classes can be used to conveniently sample CIRs and generate channel responses in the desired domain.

Once the channel responses in the time or frequency domain are computed, they can be applied to the channel input using the ApplyTimeChannel or ApplyOFDMChannel Keras layers.

The following code snippets show how to setup and run a Rayleigh block fading model assuming an OFDM waveform, and without accessing the CIRs or channel responses. This is the easiest way to setup a channel model. Setting-up other models is done in a similar way, except for AWGN (see the AWGN class documentation).

rayleigh = RayleighBlockFading(num_rx = 1,

                               num_rx_ant = 32,

                               num_tx = 4,

                               num_tx_ant = 2)



channel  = OFDMChannel(channel_model = rayleigh,

                       resource_grid = rg)

where rg is an instance of ResourceGrid.

Running the channel model is done as follows:

# x is the channel input

# no is the noise variance

y = channel([x, no])

To use the time domain representation of the channel, one can use TimeChannel instead of OFDMChannel.

If access to the channel responses is needed, one can separate their generation from their application to the channel input by setting up the channel model as follows:

rayleigh = RayleighBlockFading(num_rx = 1,

                               num_rx_ant = 32,

                               num_tx = 4,

                               num_tx_ant = 2)



generate_channel = GenerateOFDMChannel(channel_model = rayleigh,

                                       resource_grid = rg)



apply_channel = ApplyOFDMChannel()

where rg is an instance of ResourceGrid. Running the channel model is done as follows:

# Generate a batch of channel responses

h = generate_channel(batch_size)

# Apply the channel

# x is the channel input

# no is the noise variance

y = apply_channel([x, h, no])

Generating and applying the channel in the time domain can be achieved by using GenerateTimeChannel and ApplyTimeChannel instead of GenerateOFDMChannel and ApplyOFDMChannel, respectively.

To access the CIRs, setting up the channel can be done as follows:

rayleigh = RayleighBlockFading(num_rx = 1,

                               num_rx_ant = 32,

                               num_tx = 4,

                               num_tx_ant = 2)



apply_channel = ApplyOFDMChannel()

and running the channel model as follows:

cir = rayleigh(batch_size)

h = cir_to_ofdm_channel(frequencies, *cir)

y = apply_channel([x, h, no])

where frequencies are the subcarrier frequencies in the baseband, which can be computed using the subcarrier_frequencies() utility function.

Applying the channel in the time domain can be done by using cir_to_time_channel() and ApplyTimeChannel instead of cir_to_ofdm_channel() and ApplyOFDMChannel, respectively.

For the purpose of the present document, the following symbols apply:

N_T (u)

Number of transmitters (transmitter index)

N_T (u)

Number of receivers (receiver index)

N_{TA} (k)

Number of antennas per transmitter (transmit antenna index)

N_{RA} (l)

Number of antennas per receiver (receive antenna index)

N_S (s)

Number of OFDM symbols (OFDM symbol index)

N_F (n)

Number of subcarriers (subcarrier index)

N_B (b)

Number of time samples forming the channel input (baseband symbol index)

L_{\text{min}}

Smallest time-lag for the discrete complex baseband channel

L_{\text{max}}

Largest time-lag for the discrete complex baseband channel

M (m)

Number of paths (clusters) forming a power delay profile (path index)

\tau_m(t)

m^{th}

path (cluster) delay at time step

t

a_m(t)

m^{th}

path (cluster) complex coefficient at time step

\Delta_f

Subcarrier spacing

W

Bandwidth

N_0

Noise variance

All transmitters are equipped with

N_{TA}

antennas and all receivers with

N_{RA}

antennas.

A channel model, such as RayleighBlockFading or UMi, is used to generate for each link between antenna

k

of transmitter

u

and antenna

l

of receiver

v

a power delay profile

(a_{u, k, v, l, m}(t), \tau_{u, v, m}), 0 \leq m \leq M-1

. The delays are assumed not to depend on time

t

, and transmit and receive antennas

k

and

l

. Such a power delay profile corresponds to the channel impulse response

h_{u, k, v, l}(t,\tau) =

\sum_{m=0}^{M-1} a_{u, k, v, l,m}(t) \delta(\tau - \tau_{u, v, m})

where

\delta(\cdot)

is the Dirac delta measure. For example, in the case of Rayleigh block fading, the power delay profiles are time-invariant and such that for every link

(u, k, v, l)

\begin{split}\begin{align}

   M                     &= 1\\

   \tau_{u, v, 0}  &= 0\\

   a_{u, k, v, l, 0}     &\sim \mathcal{CN}(0,1).

\end{align}\end{split}

.

3GPP channel models use the procedure depicted in [TR38901] to generate power delay profiles. With these models, the power delay profiles are time-variant in the event of mobility.

### class: sionna.channel.KroneckerModel(r_tx=None, r_rx=None)
Kronecker model for spatial correlation.
Given a batch of matrices
\mathbf{H}\in\mathbb{C}^{M\times K}
,
\mathbf{R}_\text{tx}\in\mathbb{C}^{K\times K}
, and
\mathbf{R}_\text{rx}\in\mathbb{C}^{M\times M}
, this function will generate the following output:
\mathbf{H}_\text{corr} = \mathbf{R}^{\frac12}_\text{rx} \mathbf{H} \mathbf{R}^{\frac12}_\text{tx}
Note that
\mathbf{R}_\text{tx}\in\mathbb{C}^{K\times K}
and
\mathbf{R}_\text{rx}\in\mathbb{C}^{M\times M}
must be positive semi-definite, such as the ones generated by exp_corr_mat().
Parameters
r_tx ([..., K, K], tf.complex) – Tensor containing the transmit correlation matrices. If the rank of r_tx is smaller than that of the input h, it will be broadcast.
r_rx ([..., M, M], tf.complex) – Tensor containing the receive correlation matrices. If the rank of r_rx is smaller than that of the input h, it will be broadcast.
Input
h ([…, M, K], tf.complex) – Tensor containing spatially uncorrelated channel coeffficients.
Output
h_corr ([…, M, K], tf.complex) – Tensor containing the spatially correlated channel coefficients.
property
r_rx
Tensor containing the receive correlation matrices.
Note
If you want to set this property in Graph mode with XLA, i.e., within a function that is decorated with @tf.function(jit_compile=True), you must set sionna.Config.xla_compat=true. See xla_compat.
property
r_tx
Tensor containing the transmit correlation matrices.
Note
If you want to set this property in Graph mode with XLA, i.e., within a function that is decorated with @tf.function(jit_compile=True), you must set sionna.Config.xla_compat=true. See xla_compat.
### class: sionna.channel.PerColumnModel(r_rx)
Per-column model for spatial correlation.
Given a batch of matrices
\mathbf{H}\in\mathbb{C}^{M\times K}
and correlation matrices
\mathbf{R}_k\in\mathbb{C}^{M\times M}, k=1,\dots,K
, this function will generate the output
\mathbf{H}_\text{corr}\in\mathbb{C}^{M\times K}
, with columns
\mathbf{h}^\text{corr}_k = \mathbf{R}^{\frac12}_k \mathbf{h}_k,\quad k=1, \dots, K
where
\mathbf{h}_k
is the kth column of
\mathbf{H}
. Note that all
\mathbf{R}_k\in\mathbb{C}^{M\times M}
must be positive semi-definite, such as the ones generated by one_ring_corr_mat().
This model is typically used to simulate a MIMO channel between multiple single-antenna users and a base station with multiple antennas. The resulting SIMO channel for each user has a different spatial correlation.
Parameters
r_rx ([..., M, M], tf.complex) – Tensor containing the receive correlation matrices. If the rank of r_rx is smaller than that of the input h, it will be broadcast. For a typically use of this model, r_rx has shape […, K, M, M], i.e., a different correlation matrix for each column of h.
Input
h ([…, M, K], tf.complex) – Tensor containing spatially uncorrelated channel coeffficients.
Output
h_corr ([…, M, K], tf.complex) – Tensor containing the spatially correlated channel coefficients.
property
r_rx
Tensor containing the receive correlation matrices.
Note
If you want to set this property in Graph mode with XLA, i.e., within a function that is decorated with @tf.function(jit_compile=True), you must set sionna.Config.xla_compat=true. See xla_compat.
## Channel model interface
## class: sionna.channel.ChannelModel
Abstract class that defines an interface for channel models.
Any channel model which generates channel impulse responses must implement this interface. All the channel models available in Sionna, such as RayleighBlockFading or TDL, implement this interface.
Remark: Some channel models only require a subset of the input parameters.
Input
batch_size (int) – Batch size
num_time_steps (int) – Number of time steps
sampling_frequency (float) – Sampling frequency [Hz]
Output
a ([batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_paths, num_time_steps], tf.complex) – Path coefficients
tau ([batch size, num_rx, num_tx, num_paths], tf.float) – Path delays [s]
## Time domain channel
The model of the channel in the time domain assumes pulse shaping and receive filtering are performed using a conventional sinc filter (see, e.g., [Tse]). Using sinc for transmit and receive filtering, the discrete-time domain received signal at time step
y_{v, l, b} = \sum_{u=0}^{N_{T}-1}\sum_{k=0}^{N_{TA}-1}
   \sum_{\ell = L_{\text{min}}}^{L_{\text{max}}}
   \bar{h}_{u, k, v, l, b, \ell} x_{u, k, b-\ell}
   + w_{v, l, b}where
x_{u, k, b}
is the baseband symbol transmitted by transmitter
u
on antenna
k
and at time step
b
,
w_{v, l, b} \sim \mathcal{CN}\left(0,N_0\right)
the additive white Gaussian noise, and
\bar{h}_{u, k, v, l, b, \ell}
the channel filter tap at time step
b
and for time-lag
\ell
, which is given by
\bar{h}_{u, k, v, l, b, \ell}
= \sum_{m=0}^{M-1} a_{u, k, v, l, m}\left(\frac{b}{W}\right)
   \text{sinc}\left( \ell - W\tau_{u, v, m} \right).
Note
The two parameters
L_{\text{min}}
and
L_{\text{max}}
control the smallest and largest time-lag for the discrete-time channel model, respectively. They are set when instantiating TimeChannel, GenerateTimeChannel, and when calling the utility function cir_to_time_channel(). Because the sinc filter is neither time-limited nor causal, the discrete-time channel model is not causal. Therefore, ideally, one would set
L_{\text{min}} = -\infty
and
L_{\text{max}} = +\infty
. In practice, however, these two parameters need to be set to reasonable finite values. Values for these two parameters can be computed using the time_lag_discrete_time_channel() utility function from a given bandwidth and maximum delay spread. This function returns
-6
for
L_{\text{min}}*L_{\text{max}}
is computed from the specified bandwidth and maximum delay spread, which default value is
3 \mu s
. These values for
L_{\text{min}}
and the maximum delay spread were found to be valid for all the models available in Sionna when an RMS delay spread of 100ns is assumed.
### class: sionna.channel.TimeChannel(channel_model, bandwidth, num_time_samples, maximum_delay_spread=3e-6, l_min=None, l_max=None, normalize_channel=False, add_awgn=True, return_channel=False, dtype=tf.complex64, **kwargs)
Generate channel responses and apply them to channel inputs in the time domain.
This class inherits from the Keras Layer class and can be used as layer in a Keras model.
The channel output consists of num_time_samples + l_max - l_min time samples, as it is the result of filtering the channel input of length num_time_samples with the time-variant channel filter of length l_max - l_min + 1. In the case of a single-input single-output link and given a sequence of channel inputs
x_0,\cdots,x_{N_B}
, where
N_B
is num_time_samples, this layer outputs
y_b = \sum_{\ell = L_{\text{min}}}^{L_{\text{max}}} x_{b-\ell} \bar{h}_{b,\ell} + w_b
where
L_{\text{min}}
corresponds l_min,
L_{\text{max}}
to l_max,
w_b
to the additive noise, and
\bar{h}_{b,\ell}
to the
\ell^{th}
tap of the
b^{th}
channel sample. This layer outputs
y_b
for
b
ranging from
L_{\text{min}}
to
N_B + L_{\text{max}} - 1
, and
x_{b}
is set to 0 for
b < 0
or
b \geq N_B
. The channel taps
\bar{h}_{b,\ell}
are computed assuming a sinc filter is used for pulse shaping and receive filtering. Therefore, given a channel impulse response
(a_{m}(t), \tau_{m}), 0 \leq m \leq M-1
, generated by the channel_model, the channel taps are computed as follows:
\bar{h}_{b, \ell}
= \sum_{m=0}^{M-1} a_{m}\left(\frac{b}{W}\right)
    \text{sinc}\left( \ell - W\tau_{m} \right)
for
\ell
ranging from l_min to l_max, and where
W
is the bandwidth.
For multiple-input multiple-output (MIMO) links, the channel output is computed for each antenna of each receiver and by summing over all the antennas of all transmitters.
Parameters
channel_model (ChannelModel object) – An instance of a ChannelModel, such as RayleighBlockFading or UMi.
bandwidth (float) – Bandwidth (
W
) [Hz]
num_time_samples (int) – Number of time samples forming the channel input (
N_B
)
maximum_delay_spread (float) – Maximum delay spread [s]. Used to compute the default value of l_max if l_max is set to None. If a value is given for l_max, this parameter is not used. It defaults to 3us, which was found to be large enough to include most significant paths with all channel models included in Sionna assuming a nominal delay spread of 100ns.
l_min (int) – Smallest time-lag for the discrete complex baseband channel (
L_{\text{min}}
). If set to None, defaults to the value given by time_lag_discrete_time_channel().
l_max (int) – Largest time-lag for the discrete complex baseband channel (
L_{\text{max}}
). If set to None, it is computed from bandwidth and maximum_delay_spread using time_lag_discrete_time_channel(). If it is not set to None, then the parameter maximum_delay_spread is not used.
add_awgn (bool) – If set to False, no white Gaussian noise is added. Defaults to True.
normalize_channel (bool) – If set to True, the channel is normalized over the block size to ensure unit average energy per time step. Defaults to False.
return_channel (bool) – If set to True, the channel response is returned in addition to the channel output. Defaults to False.
dtype (tf.DType) – Complex datatype to use for internal processing and output. Defaults to tf.complex64.
Input
(x, no) or x – Tuple or Tensor:
x ([batch size, num_tx, num_tx_ant, num_time_samples], tf.complex) – Channel inputs
no (Scalar or Tensor, tf.float) – Scalar or tensor whose shape can be broadcast to the shape of the channel outputs: [batch size, num_rx, num_rx_ant, num_time_samples]. Only required if add_awgn is set to True. The noise power no is per complex dimension. If no is a scalar, noise of the same variance will be added to the outputs. If no is a tensor, it must have a shape that can be broadcast to the shape of the channel outputs. This allows, e.g., adding noise of different variance to each example in a batch. If no has a lower rank than the channel outputs, then no will be broadcast to the shape of the channel outputs by adding dummy dimensions after the last axis.
Output
y ([batch size, num_rx, num_rx_ant, num_time_samples + l_max - l_min], tf.complex) – Channel outputs The channel output consists of num_time_samples + l_max - l_min time samples, as it is the result of filtering the channel input of length num_time_samples with the time-variant channel filter of length l_max - l_min + 1.
h_time ([batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_time_samples + l_max - l_min, l_max - l_min + 1], tf.complex) – (Optional) Channel responses. Returned only if return_channel is set to True. For each batch example, num_time_samples + l_max - l_min time steps of the channel realizations are generated to filter the channel input.
### class: sionna.channel.GenerateTimeChannel(channel_model, bandwidth, num_time_samples, l_min, l_max, normalize_channel=False)
Generate channel responses in the time domain.
For each batch example, num_time_samples + l_max - l_min time steps of a channel realization are generated by this layer. These can be used to filter a channel input of length num_time_samples using the ApplyTimeChannel layer.
The channel taps
\bar{h}_{b,\ell}
(h_time) returned by this layer are computed assuming a sinc filter is used for pulse shaping and receive filtering. Therefore, given a channel impulse response
(a_{m}(t), \tau_{m}), 0 \leq m \leq M-1
, generated by the channel_model, the channel taps are computed as follows:
\bar{h}_{b, \ell}
= \sum_{m=0}^{M-1} a_{m}\left(\frac{b}{W}\right)
    \text{sinc}\left( \ell - W\tau_{m} \right)
for
\ell
ranging from l_min to l_max, and where
W
is the bandwidth.
Parameters
channel_model (ChannelModel object) – An instance of a ChannelModel, such as RayleighBlockFading or UMi.
bandwidth (float) – Bandwidth (
W
) [Hz]
num_time_samples (int) – Number of time samples forming the channel input (
N_B
)
l_min (int) – Smallest time-lag for the discrete complex baseband channel (
L_{\text{min}}
)
l_max (int) – Largest time-lag for the discrete complex baseband channel (
L_{\text{max}}
)
normalize_channel (bool) – If set to True, the channel is normalized over the block size to ensure unit average energy per time step. Defaults to False.
Input
batch_size (int) – Batch size. Defaults to None for channel models that do not require this paranmeter.
Output
h_time ([batch size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_time_samples + l_max - l_min, l_max - l_min + 1], tf.complex) – Channel responses. For each batch example, num_time_samples + l_max - l_min time steps of a channel realization are generated by this layer. These can be used to filter a channel input of length num_time_samples using the ApplyTimeChannel layer.
