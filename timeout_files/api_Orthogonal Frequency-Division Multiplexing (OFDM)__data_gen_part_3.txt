# Orthogonal Frequency-Division Multiplexing (OFDM)

## Precoding
### class: sionna.ofdm.ZFPrecoder(resource_grid, stream_management, return_effective_channel=False, dtype=tf.complex64, **kwargs)
## Equalization
### class: sionna.ofdm.OFDMEqualizer(equalizer, resource_grid, stream_management, dtype=tf.complex64, **kwargs)
### class: sionna.ofdm.LMMSEEqualizer(resource_grid, stream_management, whiten_interference=True, dtype=tf.complex64, **kwargs)
### class: sionna.ofdm.MFEqualizer(resource_grid, stream_management, dtype=tf.complex64, **kwargs)
### class: sionna.ofdm.ZFEqualizer(resource_grid, stream_management, dtype=tf.complex64, **kwargs)
## Detection
### class: sionna.ofdm.OFDMDetector(detector, output, resource_grid, stream_management, dtype=tf.complex64, **kwargs)
### class: sionna.ofdm.OFDMDetectorWithPrior(detector, output, resource_grid, stream_management, constellation_type, num_bits_per_symbol, constellation, dtype=tf.complex64, **kwargs)
### class: sionna.ofdm.EPDetector(output, resource_grid, stream_management, num_bits_per_symbol, hard_out=False, l=10, beta=0.9, dtype=tf.complex64, **kwargs)
### class: sionna.ofdm.KBestDetector(output, num_streams, k, resource_grid, stream_management, constellation_type=None, num_bits_per_symbol=None, constellation=None, hard_out=False, use_real_rep=False, list2llr=None, dtype=tf.complex64, **kwargs)
### class: sionna.ofdm.LinearDetector(equalizer, output, demapping_method, resource_grid, stream_management, constellation_type=None, num_bits_per_symbol=None, constellation=None, hard_out=False, dtype=tf.complex64, **kwargs)
### class: sionna.ofdm.MaximumLikelihoodDetector(output, demapping_method, resource_grid, stream_management, constellation_type=None, num_bits_per_symbol=None, constellation=None, hard_out=False, dtype=tf.complex64, **kwargs)
### class: sionna.ofdm.MaximumLikelihoodDetectorWithPrior(output, demapping_method, resource_grid, stream_management, constellation_type=None, num_bits_per_symbol=None, constellation=None, hard_out=False, dtype=tf.complex64, **kwargs)
### class: sionna.ofdm.MMSEPICDetector(output, resource_grid, stream_management, demapping_method='maxlog', num_iter=1, constellation_type=None, num_bits_per_symbol=None, constellation=None, hard_out=False, dtype=tf.complex64, **kwargs)

# Orthogonal Frequency-Division Multiplexing (OFDM)

This module provides layers and functions to support simulation of OFDM-based systems. The key component is the ResourceGrid that defines how data and pilot symbols are mapped onto a sequence of OFDM symbols with a given FFT size. The resource grid can also define guard and DC carriers which are nulled. In 4G/5G parlance, a ResourceGrid would be a slot. Once a ResourceGrid is defined, one can use the ResourceGridMapper to map a tensor of complex-valued data symbols onto the resource grid, prior to OFDM modulation using the OFDMModulator or further processing in the frequency domain.

The PilotPattern allows for a fine-grained configuration of how transmitters send pilots for each of their streams or antennas. As the management of pilots in multi-cell MIMO setups can quickly become complicated, the module provides the KroneckerPilotPattern class that automatically generates orthogonal pilot transmissions for all transmitters and streams.

Additionally, the module contains layers for channel estimation, precoding, equalization, and detection, such as the LSChannelEstimator, the ZFPrecoder, and the LMMSEEqualizer and LinearDetector. These are good starting points for the development of more advanced algorithms and provide robust baselines for benchmarking.

### class: sionna.ofdm.ZFPrecoder(resource_grid, stream_management, return_effective_channel=False, dtype=tf.complex64, **kwargs)
Zero-forcing precoding for multi-antenna transmissions.
This layer precodes a tensor containing OFDM resource grids using the zero_forcing_precoder(). For every transmitter, the channels to all intended receivers are gathered into a channel matrix, based on the which the precoding matrix is computed and the input tensor is precoded. The layer also outputs optionally the effective channel after precoding for each stream.
Parameters
resource_grid (ResourceGrid) – An instance of ResourceGrid.
stream_management (StreamManagement) – An instance of StreamManagement.
return_effective_channel (bool) – Indicates if the effective channel after precoding should be returned.
dtype (tf.Dtype) – Datatype for internal calculations and the output dtype. Defaults to tf.complex64.
Input
(x, h) – Tuple:
x ([batch_size, num_tx, num_streams_per_tx, num_ofdm_symbols, fft_size], tf.complex) – Tensor containing the resource grid to be precoded.
h ([batch_size, num_rx, num_rx_ant, num_tx, num_tx_ant, num_ofdm, fft_size], tf.complex) – Tensor containing the channel knowledge based on which the precoding is computed.
Output
x_precoded ([batch_size, num_tx, num_tx_ant, num_ofdm_symbols, fft_size], tf.complex) – The precoded resource grids.
h_eff ([batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm, num_effective_subcarriers], tf.complex) – Only returned if return_effective_channel=True. The effectice channels for all streams after precoding. Can be used to simulate perfect channel state information (CSI) at the receivers. Nulled subcarriers are automatically removed to be compliant with the behavior of a channel estimator.
Note
If you want to use this layer in Graph mode with XLA, i.e., within a function that is decorated with @tf.function(jit_compile=True), you must set sionna.Config.xla_compat=true. See xla_compat.
## Equalization
### class: sionna.ofdm.OFDMEqualizer(equalizer, resource_grid, stream_management, dtype=tf.complex64, **kwargs)
Layer that wraps a MIMO equalizer for use with the OFDM waveform.
The parameter equalizer is a callable (e.g., a function) that implements a MIMO equalization algorithm for arbitrary batch dimensions.
This class pre-processes the received resource grid y and channel estimate h_hat, and computes for each receiver the noise-plus-interference covariance matrix according to the OFDM and stream configuration provided by the resource_grid and stream_management, which also accounts for the channel estimation error variance err_var. These quantities serve as input to the equalization algorithm that is implemented by the callable equalizer. This layer computes soft-symbol estimates together with effective noise variances for all streams which can, e.g., be used by a Demapper to obtain LLRs.
Note
The callable equalizer must take three inputs:
y ([…,num_rx_ant], tf.complex) – 1+D tensor containing the received signals.
h ([…,num_rx_ant,num_streams_per_rx], tf.complex) – 2+D tensor containing the channel matrices.
s ([…,num_rx_ant,num_rx_ant], tf.complex) – 2+D tensor containing the noise-plus-interference covariance matrices.
It must generate two outputs:
x_hat ([…,num_streams_per_rx], tf.complex) – 1+D tensor representing the estimated symbol vectors.
no_eff (tf.float) – Tensor of the same shape as x_hat containing the effective noise variance estimates.
Parameters
equalizer (Callable) – Callable object (e.g., a function) that implements a MIMO equalization algorithm for arbitrary batch dimensions
resource_grid (ResourceGrid) – Instance of ResourceGrid
stream_management (StreamManagement) – Instance of StreamManagement
dtype (tf.Dtype) – Datatype for internal calculations and the output dtype. Defaults to tf.complex64.
Input
(y, h_hat, err_var, no) – Tuple:
y ([batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex) – Received OFDM resource grid after cyclic prefix removal and FFT
h_hat ([batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex) – Channel estimates for all streams from all transmitters
err_var ([Broadcastable to shape of h_hat], tf.float) – Variance of the channel estimation error
no ([batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float) – Variance of the AWGN
Output
x_hat ([batch_size, num_tx, num_streams, num_data_symbols], tf.complex) – Estimated symbols
no_eff ([batch_size, num_tx, num_streams, num_data_symbols], tf.float) – Effective noise variance for each estimated symbol
### class: sionna.ofdm.LMMSEEqualizer(resource_grid, stream_management, whiten_interference=True, dtype=tf.complex64, **kwargs)
LMMSE equalization for OFDM MIMO transmissions.
This layer computes linear minimum mean squared error (LMMSE) equalization for OFDM MIMO transmissions. The OFDM and stream configuration are provided by a ResourceGrid and StreamManagement instance, respectively. The detection algorithm is the lmmse_equalizer(). The layer computes soft-symbol estimates together with effective noise variances for all streams which can, e.g., be used by a Demapper to obtain LLRs.
Parameters
resource_grid (ResourceGrid) – Instance of ResourceGrid
stream_management (StreamManagement) – Instance of StreamManagement
whiten_interference (bool) – If True (default), the interference is first whitened before equalization. In this case, an alternative expression for the receive filter is used which can be numerically more stable.
dtype (tf.Dtype) – Datatype for internal calculations and the output dtype. Defaults to tf.complex64.
Input
(y, h_hat, err_var, no) – Tuple:
y ([batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex) – Received OFDM resource grid after cyclic prefix removal and FFT
h_hat ([batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex) – Channel estimates for all streams from all transmitters
err_var ([Broadcastable to shape of h_hat], tf.float) – Variance of the channel estimation error
no ([batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float) – Variance of the AWGN
Output
x_hat ([batch_size, num_tx, num_streams, num_data_symbols], tf.complex) – Estimated symbols
no_eff ([batch_size, num_tx, num_streams, num_data_symbols], tf.float) – Effective noise variance for each estimated symbol
Note
If you want to use this layer in Graph mode with XLA, i.e., within a function that is decorated with @tf.function(jit_compile=True), you must set sionna.Config.xla_compat=true. See xla_compat.
### class: sionna.ofdm.MFEqualizer(resource_grid, stream_management, dtype=tf.complex64, **kwargs)
MF equalization for OFDM MIMO transmissions.
This layer computes matched filter (MF) equalization for OFDM MIMO transmissions. The OFDM and stream configuration are provided by a ResourceGrid and StreamManagement instance, respectively. The detection algorithm is the mf_equalizer(). The layer computes soft-symbol estimates together with effective noise variances for all streams which can, e.g., be used by a Demapper to obtain LLRs.
Parameters
resource_grid (ResourceGrid) – An instance of ResourceGrid.
stream_management (StreamManagement) – An instance of StreamManagement.
dtype (tf.Dtype) – Datatype for internal calculations and the output dtype. Defaults to tf.complex64.
Input
(y, h_hat, err_var, no) – Tuple:
y ([batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex) – Received OFDM resource grid after cyclic prefix removal and FFT
h_hat ([batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex) – Channel estimates for all streams from all transmitters
err_var ([Broadcastable to shape of h_hat], tf.float) – Variance of the channel estimation error
no ([batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float) – Variance of the AWGN
Output
x_hat ([batch_size, num_tx, num_streams, num_data_symbols], tf.complex) – Estimated symbols
no_eff ([batch_size, num_tx, num_streams, num_data_symbols], tf.float) – Effective noise variance for each estimated symbol
Note
If you want to use this layer in Graph mode with XLA, i.e., within a function that is decorated with @tf.function(jit_compile=True), you must set sionna.Config.xla_compat=true. See xla_compat.
### class: sionna.ofdm.ZFEqualizer(resource_grid, stream_management, dtype=tf.complex64, **kwargs)
ZF equalization for OFDM MIMO transmissions.
This layer computes zero-forcing (ZF) equalization for OFDM MIMO transmissions. The OFDM and stream configuration are provided by a ResourceGrid and StreamManagement instance, respectively. The detection algorithm is the zf_equalizer(). The layer computes soft-symbol estimates together with effective noise variances for all streams which can, e.g., be used by a Demapper to obtain LLRs.
Parameters
resource_grid (ResourceGrid) – An instance of ResourceGrid.
stream_management (StreamManagement) – An instance of StreamManagement.
dtype (tf.Dtype) – Datatype for internal calculations and the output dtype. Defaults to tf.complex64.
Input
(y, h_hat, err_var, no) – Tuple:
y ([batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex) – Received OFDM resource grid after cyclic prefix removal and FFT
h_hat ([batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex) – Channel estimates for all streams from all transmitters
err_var ([Broadcastable to shape of h_hat], tf.float) – Variance of the channel estimation error
no ([batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float) – Variance of the AWGN
Output
x_hat ([batch_size, num_tx, num_streams, num_data_symbols], tf.complex) – Estimated symbols
no_eff ([batch_size, num_tx, num_streams, num_data_symbols], tf.float) – Effective noise variance for each estimated symbol
Note
If you want to use this layer in Graph mode with XLA, i.e., within a function that is decorated with @tf.function(jit_compile=True), you must set sionna.Config.xla_compat=true. See xla_compat.
## Detection
### class: sionna.ofdm.OFDMDetector(detector, output, resource_grid, stream_management, dtype=tf.complex64, **kwargs)
Layer that wraps a MIMO detector for use with the OFDM waveform.
The parameter detector is a callable (e.g., a function) that implements a MIMO detection algorithm for arbitrary batch dimensions.
This class pre-processes the received resource grid y and channel estimate h_hat, and computes for each receiver the noise-plus-interference covariance matrix according to the OFDM and stream configuration provided by the resource_grid and stream_management, which also accounts for the channel estimation error variance err_var. These quantities serve as input to the detection algorithm that is implemented by detector. Both detection of symbols or bits with either soft- or hard-decisions are supported.
Note
The callable detector must take as input a tuple
(\mathbf{y}, \mathbf{h}, \mathbf{s})
such that:
y ([…,num_rx_ant], tf.complex) – 1+D tensor containing the received signals.
h ([…,num_rx_ant,num_streams_per_rx], tf.complex) – 2+D tensor containing the channel matrices.
s ([…,num_rx_ant,num_rx_ant], tf.complex) – 2+D tensor containing the noise-plus-interference covariance matrices.
It must generate one of following outputs depending on the value of output:
b_hat ([…, num_streams_per_rx, num_bits_per_symbol], tf.float) – LLRs or hard-decisions for every bit of every stream, if output equals “bit”.
x_hat ([…, num_streams_per_rx, num_points], tf.float) or ([…, num_streams_per_rx], tf.int) – Logits or hard-decisions for constellation symbols for every stream, if output equals “symbol”. Hard-decisions correspond to the symbol indices.
Parameters
detector (Callable) – Callable object (e.g., a function) that implements a MIMO detection algorithm for arbitrary batch dimensions. Either one of the existing detectors, e.g., LinearDetector, MaximumLikelihoodDetector, or KBestDetector can be used, or a custom detector callable provided that has the same input/output specification.
output (One of ["bit", "symbol"], str) – Type of output, either bits or symbols
resource_grid (ResourceGrid) – Instance of ResourceGrid
stream_management (StreamManagement) – Instance of StreamManagement
dtype (One of [tf.complex64, tf.complex128] tf.DType (dtype)) – The dtype of y. Defaults to tf.complex64. The output dtype is the corresponding real dtype (tf.float32 or tf.float64).
Input
(y, h_hat, err_var, no) – Tuple:
y ([batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex) – Received OFDM resource grid after cyclic prefix removal and FFT
h_hat ([batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex) – Channel estimates for all streams from all transmitters
err_var ([Broadcastable to shape of h_hat], tf.float) – Variance of the channel estimation error
no ([batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float) – Variance of the AWGN
Output
One of
[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float – LLRs or hard-decisions for every bit of every stream, if output equals “bit”
[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int – Logits or hard-decisions for constellation symbols for every stream, if output equals “symbol”. Hard-decisions correspond to the symbol indices.
### class: sionna.ofdm.OFDMDetectorWithPrior(detector, output, resource_grid, stream_management, constellation_type, num_bits_per_symbol, constellation, dtype=tf.complex64, **kwargs)
Layer that wraps a MIMO detector that assumes prior knowledge of the bits or constellation points is available, for use with the OFDM waveform.
The parameter detector is a callable (e.g., a function) that implements a MIMO detection algorithm with prior for arbitrary batch dimensions.
This class pre-processes the received resource grid y, channel estimate h_hat, and the prior information prior, and computes for each receiver the noise-plus-interference covariance matrix according to the OFDM and stream configuration provided by the resource_grid and stream_management, which also accounts for the channel estimation error variance err_var. These quantities serve as input to the detection algorithm that is implemented by detector. Both detection of symbols or bits with either soft- or hard-decisions are supported.
Note
The callable detector must take as input a tuple
(\mathbf{y}, \mathbf{h}, \mathbf{prior}, \mathbf{s})
such that:
y ([…,num_rx_ant], tf.complex) – 1+D tensor containing the received signals.
h ([…,num_rx_ant,num_streams_per_rx], tf.complex) – 2+D tensor containing the channel matrices.
prior ([…,num_streams_per_rx,num_bits_per_symbol] or […,num_streams_per_rx,num_points], tf.float) – Prior for the transmitted signals. If output equals “bit”, then LLRs for the transmitted bits are expected. If output equals “symbol”, then logits for the transmitted constellation points are expected.
s ([…,num_rx_ant,num_rx_ant], tf.complex) – 2+D tensor containing the noise-plus-interference covariance matrices.
It must generate one of the following outputs depending on the value of output:
b_hat ([…, num_streams_per_rx, num_bits_per_symbol], tf.float) – LLRs or hard-decisions for every bit of every stream, if output equals “bit”.
x_hat ([…, num_streams_per_rx, num_points], tf.float) or ([…, num_streams_per_rx], tf.int) – Logits or hard-decisions for constellation symbols for every stream, if output equals “symbol”. Hard-decisions correspond to the symbol indices.
Parameters
detector (Callable) – Callable object (e.g., a function) that implements a MIMO detection algorithm with prior for arbitrary batch dimensions. Either the existing detector MaximumLikelihoodDetectorWithPrior can be used, or a custom detector callable provided that has the same input/output specification.
output (One of ["bit", "symbol"], str) – Type of output, either bits or symbols
resource_grid (ResourceGrid) – Instance of ResourceGrid
stream_management (StreamManagement) – Instance of StreamManagement
constellation_type (One of ["qam", "pam", "custom"], str) – For “custom”, an instance of Constellation must be provided.
num_bits_per_symbol (int) – Number of bits per constellation symbol, e.g., 4 for QAM16. Only required for constellation_type in [“qam”, “pam”].
constellation (Constellation) – Instance of Constellation or None. In the latter case, constellation_type and num_bits_per_symbol must be provided.
dtype (One of [tf.complex64, tf.complex128] tf.DType (dtype)) – The dtype of y. Defaults to tf.complex64. The output dtype is the corresponding real dtype (tf.float32 or tf.float64).
Input
(y, h_hat, prior, err_var, no) – Tuple:
y ([batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex) – Received OFDM resource grid after cyclic prefix removal and FFT
h_hat ([batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex) – Channel estimates for all streams from all transmitters
prior ([batch_size, num_tx, num_streams, num_data_symbols x num_bits_per_symbol] or [batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float) – Prior of the transmitted signals. If output equals “bit”, LLRs of the transmitted bits are expected. If output equals “symbol”, logits of the transmitted constellation points are expected.
err_var ([Broadcastable to shape of h_hat], tf.float) – Variance of the channel estimation error
no ([batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float) – Variance of the AWGN
Output
One of
[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float – LLRs or hard-decisions for every bit of every stream, if output equals “bit”.
[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int – Logits or hard-decisions for constellation symbols for every stream, if output equals “symbol”. Hard-decisions correspond to the symbol indices.
### class: sionna.ofdm.EPDetector(output, resource_grid, stream_management, num_bits_per_symbol, hard_out=False, l=10, beta=0.9, dtype=tf.complex64, **kwargs)
This layer wraps the MIMO EP detector for use with the OFDM waveform.
Both detection of symbols or bits with either soft- or hard-decisions are supported. The OFDM and stream configuration are provided by a ResourceGrid and StreamManagement instance, respectively. The actual detector is an instance of EPDetector.
Parameters
output (One of ["bit", "symbol"], str) – Type of output, either bits or symbols. Whether soft- or hard-decisions are returned can be configured with the hard_out flag.
resource_grid (ResourceGrid) – Instance of ResourceGrid
stream_management (StreamManagement) – Instance of StreamManagement
num_bits_per_symbol (int) – Number of bits per constellation symbol, e.g., 4 for QAM16. Only required for constellation_type in [“qam”, “pam”].
hard_out (bool) – If True, the detector computes hard-decided bit values or constellation point indices instead of soft-values. Defaults to False.
l (int) – Number of iterations. Defaults to 10.
beta (float) – Parameter
\beta\in[0,1]
for update smoothing. Defaults to 0.9.
dtype (One of [tf.complex64, tf.complex128] tf.DType (dtype)) – Precision used for internal computations. Defaults to tf.complex64. Especially for large MIMO setups, the precision can make a significant performance difference.
Input
(y, h_hat, err_var, no) – Tuple:
y ([batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex) – Received OFDM resource grid after cyclic prefix removal and FFT
h_hat ([batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex) – Channel estimates for all streams from all transmitters
err_var ([Broadcastable to shape of h_hat], tf.float) – Variance of the channel estimation error
no ([batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float) – Variance of the AWGN
Output
One of
[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float – LLRs or hard-decisions for every bit of every stream, if output equals “bit”.
[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int – Logits or hard-decisions for constellation symbols for every stream, if output equals “symbol”. Hard-decisions correspond to the symbol indices.
Note
For numerical stability, we do not recommend to use this function in Graph mode with XLA, i.e., within a function that is decorated with @tf.function(jit_compile=True). However, it is possible to do so by setting sionna.Config.xla_compat=true. See xla_compat.
### class: sionna.ofdm.KBestDetector(output, num_streams, k, resource_grid, stream_management, constellation_type=None, num_bits_per_symbol=None, constellation=None, hard_out=False, use_real_rep=False, list2llr=None, dtype=tf.complex64, **kwargs)
This layer wraps the MIMO K-Best detector for use with the OFDM waveform.
Both detection of symbols or bits with either soft- or hard-decisions are supported. The OFDM and stream configuration are provided by a ResourceGrid and StreamManagement instance, respectively. The actual detector is an instance of KBestDetector.
Parameters
output (One of ["bit", "symbol"], str) – Type of output, either bits or symbols. Whether soft- or hard-decisions are returned can be configured with the hard_out flag.
num_streams (tf.int) – Number of transmitted streams
k (tf.int) – Number of paths to keep. Cannot be larger than the number of constellation points to the power of the number of streams.
resource_grid (ResourceGrid) – Instance of ResourceGrid
stream_management (StreamManagement) – Instance of StreamManagement
constellation_type (One of ["qam", "pam", "custom"], str) – For “custom”, an instance of Constellation must be provided.
num_bits_per_symbol (int) – Number of bits per constellation symbol, e.g., 4 for QAM16. Only required for constellation_type in [“qam”, “pam”].
constellation (Constellation) – Instance of Constellation or None. In the latter case, constellation_type and num_bits_per_symbol must be provided.
hard_out (bool) – If True, the detector computes hard-decided bit values or constellation point indices instead of soft-values. Defaults to False.
use_real_rep (bool) – If True, the detector use the real-valued equivalent representation of the channel. Note that this only works with a QAM constellation. Defaults to False.
list2llr (None or instance of List2LLR) – The function to be used to compute LLRs from a list of candidate solutions. If None, the default solution List2LLRSimple is used.
dtype (One of [tf.complex64, tf.complex128] tf.DType (dtype)) – The dtype of y. Defaults to tf.complex64. The output dtype is the corresponding real dtype (tf.float32 or tf.float64).
Input
(y, h_hat, err_var, no) – Tuple:
y ([batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex) – Received OFDM resource grid after cyclic prefix removal and FFT
h_hat ([batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex) – Channel estimates for all streams from all transmitters
err_var ([Broadcastable to shape of h_hat], tf.float) – Variance of the channel estimation error
no ([batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float) – Variance of the AWGN
Output
One of
[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float – LLRs or hard-decisions for every bit of every stream, if output equals “bit”.
[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int – Logits or hard-decisions for constellation symbols for every stream, if output equals “symbol”. Hard-decisions correspond to the symbol indices.
Note
If you want to use this layer in Graph mode with XLA, i.e., within a function that is decorated with @tf.function(jit_compile=True), you must set sionna.Config.xla_compat=true. See xla_compat.
### class: sionna.ofdm.LinearDetector(equalizer, output, demapping_method, resource_grid, stream_management, constellation_type=None, num_bits_per_symbol=None, constellation=None, hard_out=False, dtype=tf.complex64, **kwargs)
This layer wraps a MIMO linear equalizer and a Demapper for use with the OFDM waveform.
Both detection of symbols or bits with either soft- or hard-decisions are supported. The OFDM and stream configuration are provided by a ResourceGrid and StreamManagement instance, respectively. The actual detector is an instance of LinearDetector.
Parameters
equalizer (str, one of ["lmmse", "zf", "mf"], or an equalizer function) – Equalizer to be used. Either one of the existing equalizers, e.g., lmmse_equalizer(), zf_equalizer(), or mf_equalizer() can be used, or a custom equalizer function provided that has the same input/output specification.
output (One of ["bit", "symbol"], str) – Type of output, either bits or symbols. Whether soft- or hard-decisions are returned can be configured with the hard_out flag.
demapping_method (One of ["app", "maxlog"], str) – Demapping method used
resource_grid (ResourceGrid) – Instance of ResourceGrid
stream_management (StreamManagement) – Instance of StreamManagement
constellation_type (One of ["qam", "pam", "custom"], str) – For “custom”, an instance of Constellation must be provided.
num_bits_per_symbol (int) – Number of bits per constellation symbol, e.g., 4 for QAM16. Only required for constellation_type in [“qam”, “pam”].
constellation (Constellation) – Instance of Constellation or None. In the latter case, constellation_type and num_bits_per_symbol must be provided.
hard_out (bool) – If True, the detector computes hard-decided bit values or constellation point indices instead of soft-values. Defaults to False.
dtype (One of [tf.complex64, tf.complex128] tf.DType (dtype)) – The dtype of y. Defaults to tf.complex64. The output dtype is the corresponding real dtype (tf.float32 or tf.float64).
Input
(y, h_hat, err_var, no) – Tuple:
y ([batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex) – Received OFDM resource grid after cyclic prefix removal and FFT
h_hat ([batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex) – Channel estimates for all streams from all transmitters
err_var ([Broadcastable to shape of h_hat], tf.float) – Variance of the channel estimation error
no ([batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float) – Variance of the AWGN
Output
One of
[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float – LLRs or hard-decisions for every bit of every stream, if output equals “bit”.
[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int – Logits or hard-decisions for constellation symbols for every stream, if output equals “symbol”. Hard-decisions correspond to the symbol indices.
Note
If you want to use this layer in Graph mode with XLA, i.e., within a function that is decorated with @tf.function(jit_compile=True), you must set sionna.Config.xla_compat=true. See xla_compat.
### class: sionna.ofdm.MaximumLikelihoodDetector(output, demapping_method, resource_grid, stream_management, constellation_type=None, num_bits_per_symbol=None, constellation=None, hard_out=False, dtype=tf.complex64, **kwargs)
Maximum-likelihood (ML) detection for OFDM MIMO transmissions.
This layer implements maximum-likelihood (ML) detection for OFDM MIMO transmissions. Both ML detection of symbols or bits with either soft- or hard-decisions are supported. The OFDM and stream configuration are provided by a ResourceGrid and StreamManagement instance, respectively. The actual detector is an instance of MaximumLikelihoodDetector.
Parameters
output (One of ["bit", "symbol"], str) – Type of output, either bits or symbols. Whether soft- or hard-decisions are returned can be configured with the hard_out flag.
demapping_method (One of ["app", "maxlog"], str) – Demapping method used
resource_grid (ResourceGrid) – Instance of ResourceGrid
stream_management (StreamManagement) – Instance of StreamManagement
constellation_type (One of ["qam", "pam", "custom"], str) – For “custom”, an instance of Constellation must be provided.
num_bits_per_symbol (int) – Number of bits per constellation symbol, e.g., 4 for QAM16. Only required for constellation_type in [“qam”, “pam”].
constellation (Constellation) – Instance of Constellation or None. In the latter case, constellation_type and num_bits_per_symbol must be provided.
hard_out (bool) – If True, the detector computes hard-decided bit values or constellation point indices instead of soft-values. Defaults to False.
dtype (One of [tf.complex64, tf.complex128] tf.DType (dtype)) – The dtype of y. Defaults to tf.complex64. The output dtype is the corresponding real dtype (tf.float32 or tf.float64).
Input
(y, h_hat, err_var, no) – Tuple:
y ([batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex) – Received OFDM resource grid after cyclic prefix removal and FFT
h_hat ([batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex) – Channel estimates for all streams from all transmitters
err_var ([Broadcastable to shape of h_hat], tf.float) – Variance of the channel estimation error
no ([batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float) – Variance of the AWGN noise
Output
One of
[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float – LLRs or hard-decisions for every bit of every stream, if output equals “bit”.
[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int – Logits or hard-decisions for constellation symbols for every stream, if output equals “symbol”. Hard-decisions correspond to the symbol indices.
Note
If you want to use this layer in Graph mode with XLA, i.e., within a function that is decorated with @tf.function(jit_compile=True), you must set sionna.Config.xla_compat=true. See xla_compat.
### class: sionna.ofdm.MaximumLikelihoodDetectorWithPrior(output, demapping_method, resource_grid, stream_management, constellation_type=None, num_bits_per_symbol=None, constellation=None, hard_out=False, dtype=tf.complex64, **kwargs)
Maximum-likelihood (ML) detection for OFDM MIMO transmissions, assuming prior knowledge of the bits or constellation points is available.
This layer implements maximum-likelihood (ML) detection for OFDM MIMO transmissions assuming prior knowledge on the transmitted data is available. Both ML detection of symbols or bits with either soft- or hard-decisions are supported. The OFDM and stream configuration are provided by a ResourceGrid and StreamManagement instance, respectively. The actual detector is an instance of MaximumLikelihoodDetectorWithPrior.
Parameters
output (One of ["bit", "symbol"], str) – Type of output, either bits or symbols. Whether soft- or hard-decisions are returned can be configured with the hard_out flag.
demapping_method (One of ["app", "maxlog"], str) – Demapping method used
resource_grid (ResourceGrid) – Instance of ResourceGrid
stream_management (StreamManagement) – Instance of StreamManagement
constellation_type (One of ["qam", "pam", "custom"], str) – For “custom”, an instance of Constellation must be provided.
num_bits_per_symbol (int) – Number of bits per constellation symbol, e.g., 4 for QAM16. Only required for constellation_type in [“qam”, “pam”].
constellation (Constellation) – Instance of Constellation or None. In the latter case, constellation_type and num_bits_per_symbol must be provided.
hard_out (bool) – If True, the detector computes hard-decided bit values or constellation point indices instead of soft-values. Defaults to False.
dtype (One of [tf.complex64, tf.complex128] tf.DType (dtype)) – The dtype of y. Defaults to tf.complex64. The output dtype is the corresponding real dtype (tf.float32 or tf.float64).
Input
(y, h_hat, prior, err_var, no) – Tuple:
y ([batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex) – Received OFDM resource grid after cyclic prefix removal and FFT
h_hat ([batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex) – Channel estimates for all streams from all transmitters
prior ([batch_size, num_tx, num_streams, num_data_symbols x num_bits_per_symbol] or [batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float) – Prior of the transmitted signals. If output equals “bit”, LLRs of the transmitted bits are expected. If output equals “symbol”, logits of the transmitted constellation points are expected.
err_var ([Broadcastable to shape of h_hat], tf.float) – Variance of the channel estimation error
no ([batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float) – Variance of the AWGN noise
Output
One of
[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float – LLRs or hard-decisions for every bit of every stream, if output equals “bit”.
[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int – Logits or hard-decisions for constellation symbols for every stream, if output equals “symbol”. Hard-decisions correspond to the symbol indices.
Note
If you want to use this layer in Graph mode with XLA, i.e., within a function that is decorated with @tf.function(jit_compile=True), you must set sionna.Config.xla_compat=true. See xla_compat.
### class: sionna.ofdm.MMSEPICDetector(output, resource_grid, stream_management, demapping_method='maxlog', num_iter=1, constellation_type=None, num_bits_per_symbol=None, constellation=None, hard_out=False, dtype=tf.complex64, **kwargs)
This layer wraps the MIMO MMSE PIC detector for use with the OFDM waveform.
Both detection of symbols or bits with either soft- or hard-decisions are supported. The OFDM and stream configuration are provided by a ResourceGrid and StreamManagement instance, respectively. The actual detector is an instance of MMSEPICDetector.
Parameters
output (One of ["bit", "symbol"], str) – Type of output, either bits or symbols. Whether soft- or hard-decisions are returned can be configured with the hard_out flag.
resource_grid (ResourceGrid) – Instance of ResourceGrid
stream_management (StreamManagement) – Instance of StreamManagement
demapping_method (One of ["app", "maxlog"], str) – The demapping method used. Defaults to “maxlog”.
num_iter (int) – Number of MMSE PIC iterations. Defaults to 1.
constellation_type (One of ["qam", "pam", "custom"], str) – For “custom”, an instance of Constellation must be provided.
num_bits_per_symbol (int) – The number of bits per constellation symbol, e.g., 4 for QAM16. Only required for constellation_type in [“qam”, “pam”].
constellation (Constellation) – An instance of Constellation or None. In the latter case, constellation_type and num_bits_per_symbol must be provided.
hard_out (bool) – If True, the detector computes hard-decided bit values or constellation point indices instead of soft-values. Defaults to False.
dtype (One of [tf.complex64, tf.complex128] tf.DType (dtype)) – Precision used for internal computations. Defaults to tf.complex64. Especially for large MIMO setups, the precision can make a significant performance difference.
Input
(y, h_hat, prior, err_var, no) – Tuple:
y ([batch_size, num_rx, num_rx_ant, num_ofdm_symbols, fft_size], tf.complex) – Received OFDM resource grid after cyclic prefix removal and FFT
h_hat ([batch_size, num_rx, num_rx_ant, num_tx, num_streams_per_tx, num_ofdm_symbols, num_effective_subcarriers], tf.complex) – Channel estimates for all streams from all transmitters
prior ([batch_size, num_tx, num_streams, num_data_symbols x num_bits_per_symbol] or [batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float) – Prior of the transmitted signals. If output equals “bit”, LLRs of the transmitted bits are expected. If output equals “symbol”, logits of the transmitted constellation points are expected.
err_var ([Broadcastable to shape of h_hat], tf.float) – Variance of the channel estimation error
no ([batch_size, num_rx, num_rx_ant] (or only the first n dims), tf.float) – Variance of the AWGN
Output
One of
[batch_size, num_tx, num_streams, num_data_symbols*num_bits_per_symbol], tf.float – LLRs or hard-decisions for every bit of every stream, if output equals “bit”.
[batch_size, num_tx, num_streams, num_data_symbols, num_points], tf.float or [batch_size, num_tx, num_streams, num_data_symbols], tf.int – Logits or hard-decisions for constellation symbols for every stream, if output equals “symbol”. Hard-decisions correspond to the symbol indices.
Note
For numerical stability, we do not recommend to use this function in Graph mode with XLA, i.e., within a function that is decorated with @tf.function(jit_compile=True). However, it is possible to do so by setting sionna.Config.xla_compat=true. See xla_compat.
Previous
Next
© Copyright 2021-2023 NVIDIA CORPORATION.
Built with Sphinx using a theme provided by Read the Docs.