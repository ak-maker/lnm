# Ray Tracing

## Scene
### class: sionna.rt.Scene
### sionna.rt.Scene.compute_paths(self, max_depth=3, method='fibonacci', num_samples=1000000, los=True, reflection=True, diffraction=False, scattering=False, scat_keep_prob=0.001, edge_diffraction=False, check_scene=True, scat_random_phases=True, testing=False)
### sionna.rt.Scene.trace_paths(self, max_depth=3, method='fibonacci', num_samples=1000000, los=True, reflection=True, diffraction=False, scattering=False, scat_keep_prob=0.001, edge_diffraction=False, check_scene=True)
### sionna.rt.Scene.compute_fields(self, spec_paths, diff_paths, scat_paths, spec_paths_tmp, diff_paths_tmp, scat_paths_tmp, check_scene=True, scat_random_phases=True)

# Ray Tracing

This module provides a differentiable ray tracer for radio propagation modeling. The best way to get started is by having a look at the Sionna Ray Tracing Tutorial. The Primer on Electromagnetics provides useful background knowledge and various definitions that are used throughout the API documentation.

The most important component of the ray tracer is the Scene. It has methods for the computation of propagation Paths (compute_paths()) and CoverageMap (coverage_map()). Sionna has several integrated Example Scenes that you can use for your own experiments. In this video, we explain how you can create your own scenes using OpenStreetMap and Blender. You can preview a scene within a Jupyter notebook (preview()) or render it to a file from the viewpoint of a camera (render() or render_to_file()).

Propagation Paths can be transformed into time-varying channel impulse responses (CIRs) via cir(). The CIRs can then be used for link-level simulations in Sionna via the functions cir_to_time_channel() or cir_to_ofdm_channel(). Alternatively, you can create a dataset of CIRs that can be used by a channel model with the help of CIRDataset.

The paper Sionna RT: Differentiable Ray Tracing for Radio Propagation Modeling shows how differentiable ray tracing can be used for various optimization tasks. The related notebooks can be a good starting point for your own experiments.

## Scene
The scene contains everything that is needed for radio propagation simulation and rendering.
A scene is a collection of multiple instances of SceneObject which define the geometry and materials of the objects in the scene. The scene also includes transmitters (Transmitter) and receivers (Receiver) for which propagation Paths or channel impulse responses (CIRs) can be computed, as well as cameras (Camera) for rendering.
A scene is loaded from a file using the load_scene() function. Sionna contains a few Example Scenes. The following code snippet shows how to load one of them and render it through the lens of the preconfigured scene Camera “scene-cam-0”:
scene = load_scene(sionna.rt.scene.munich)
scene.render(camera="scene-cam-0")
You can preview a scene in an interactive 3D viewer within a Jupyter notebook using preview():
scene.preview()
In the code snippet above, the load_scene() function returns the Scene instance which can be used to access scene objects, transmitters, receivers, cameras, and to set the frequency for radio wave propagation simulation. Note that you can load only a single scene at a time.
It is important to understand that all transmitters in a scene share the same AntennaArray which can be set through the scene property tx_array. The same holds for all receivers whose AntennaArray can be set through rx_array. However, each transmitter and receiver can have a different position and orientation.
The code snippet below shows how to configure the tx_array and rx_array and to instantiate a transmitter and receiver.
# Configure antenna array for all transmitters
scene.tx_array = PlanarArray(num_rows=8,
                          num_cols=2,
                          vertical_spacing=0.7,
                          horizontal_spacing=0.5,
                          pattern="tr38901",
                          polarization="VH")

# Configure antenna array for all receivers
scene.rx_array = PlanarArray(num_rows=1,
                          num_cols=1,
                          vertical_spacing=0.5,
                          horizontal_spacing=0.5,
                          pattern="dipole",
                          polarization="cross")

# Create transmitter
tx = Transmitter(name="tx",
              position=[8.5,21,27],
              orientation=[0,0,0])
scene.add(tx)

# Create a receiver
rx = Receiver(name="rx",
           position=[45,90,1.5],
           orientation=[0,0,0])
scene.add(rx)

# TX points towards RX
tx.look_at(rx)

print(scene.transmitters)
print(scene.receivers)
{'tx': <sionna.rt.transmitter.Transmitter object at 0x7f83d0555d30>}
{'rx': <sionna.rt.receiver.Receiver object at 0x7f81f00ef0a0>}
Once you have loaded a scene and configured transmitters and receivers, you can use the scene method compute_paths() to compute propagation paths:
paths = scene.compute_paths()
The output of this function is an instance of Paths and can be used to compute channel impulse responses (CIRs) using the method cir(). You can visualize the paths within a scene by one of the following commands:
scene.preview(paths=paths) # Open preview showing paths
scene.render(camera="preview", paths=paths) # Render scene with paths from preview camera
scene.render_to_file(camera="preview",
                     filename="scene.png",
                     paths=paths) # Render scene with paths to file
Note that the calls to the render functions in the code above use the “preview” camera which is configured through preview(). You can use any other Camera that you create here as well.
The function coverage_map() computes a CoverageMap for every transmitter in a scene:
cm = scene.coverage_map(cm_cell_size=[1.,1.], # Configure size of each cell
                        num_samples=1e7) # Number of rays to trace
Coverage maps can be visualized in the same way as propagation paths:
scene.preview(coverage_map=cm) # Open preview showing coverage map
scene.render(camera="preview", coverage_map=cm) # Render scene with coverage map
scene.render_to_file(camera="preview",
                     filename="scene.png",
                     coverage_map=cm) # Render scene with coverage map to file
### class: sionna.rt.Scene
The scene contains everything that is needed for radio propagation simulation and rendering.
A scene is a collection of multiple instances of SceneObject which define the geometry and materials of the objects in the scene. The scene also includes transmitters (Transmitter) and receivers (Receiver) for which propagation Paths, channel impulse responses (CIRs) or coverage maps (CoverageMap) can be computed, as well as cameras (Camera) for rendering.
The only way to instantiate a scene is by calling load_scene(). Note that only a single scene can be loaded at a time.
Example scenes can be loaded as follows:
scene = load_scene(sionna.rt.scene.munich)
scene.preview()
add(item)[source]
Adds a transmitter, receiver, radio material, or camera to the scene.
If a different item with the same name as item is already part of the scene, an error is raised.
Input
item (Transmitter | Receiver | RadioMaterial | Camera) – Item to add to the scene
property
cameras
Dictionary of cameras in the scene
Type
dict (read-only), { “name”, Camera}
property
center
Get the center of the scene
Type
[3], tf.float
property
dtype
Datatype used in tensors
Type
tf.complex64 | tf.complex128
property
frequency
Get/set the carrier frequency [Hz]
Setting the frequency updates the parameters of frequency-dependent radio materials. Defaults to 3.5e9.
Type
float
get(name)[source]
Returns a scene object, transmitter, receiver, camera, or radio material
Input
name (str) – Name of the item to retrieve
Output
item (SceneObject | RadioMaterial | Transmitter | Receiver | Camera | None) – Retrieved item. Returns None if no corresponding item was found in the scene.
property
objects
Dictionary of scene objects
Type
dict (read-only), { “name”, SceneObject}
property
radio_material_callable
Get/set a callable that computes the radio material properties at the points of intersection between the rays and the scene objects.
If set, then the RadioMaterial of the objects are not used and the callable is invoked instead to obtain the electromagnetic properties required to simulate the propagation of radio waves.
If not set, i.e., None (default), then the RadioMaterial of objects are used to simulate the propagation of radio waves in the scene.
This callable is invoked on batches of intersection points. It takes as input the following tensors:
object_id ([batch_dims], int) : Integers uniquely identifying the intersected objects
points ([batch_dims, 3], float) : Positions of the intersection points
The callable must output a tuple/list of the following tensors:
complex_relative_permittivity ([batch_dims], complex) : Complex relative permittivities
\eta
(9)
scattering_coefficient ([batch_dims], float) : Scattering coefficients
S\in[0,1]
(37)
xpd_coefficient ([batch_dims], float) : Cross-polarization discrimination coefficients
K_x\in[0,1]
(39). Only relevant for the scattered field.
Note: The number of batch dimensions is not necessarily equal to one.
property
radio_materials
Dictionary of radio materials
Type
dict (read-only), { “name”, RadioMaterial}
property
receivers
Dictionary of receivers in the scene
Type
dict (read-only), { “name”, Receiver}
remove(name)[source]
Removes a transmitter, receiver, camera, or radio material from the scene.
In the case of a radio material, it must not be used by any object of the scene.
Input
name (str) – Name of the item to remove
property
rx_array
Get/set the antenna array used by all receivers in the scene. Defaults to None.
Type
AntennaArray
property
scattering_pattern_callable
Get/set a callable that computes the scattering pattern at the points of intersection between the rays and the scene objects.
If set, then the scattering_pattern of the radio materials of the objects are not used and the callable is invoked instead to evaluate the scattering pattern required to simulate the propagation of diffusely reflected radio waves.
If not set, i.e., None (default), then the scattering_pattern of the objects’ radio materials are used to simulate the propagation of diffusely reflected radio waves in the scene.
This callable is invoked on batches of intersection points. It takes as input the following tensors:
object_id ([batch_dims], int) : Integers uniquely identifying the intersected objects
points ([batch_dims, 3], float) : Positions of the intersection points
k_i ([batch_dims, 3], float) : Unitary vector corresponding to the direction of incidence in the scene’s global coordinate system
k_s ([batch_dims, 3], float) : Unitary vector corresponding to the direction of the diffuse reflection in the scene’s global coordinate system
n ([batch_dims, 3], float) : Unitary vector corresponding to the normal to the surface at the intersection point
The callable must output the following tensor:
f_s ([batch_dims], float) : The scattering pattern evaluated for the previous inputs
Note: The number of batch dimensions is not necessarily equal to one.
property
size
Get the size of the scene, i.e., the size of the axis-aligned minimum bounding box for the scene
Type
[3], tf.float
property
synthetic_array
Get/set if the antenna arrays are applied synthetically. Defaults to True.
Type
bool
property
transmitters
Dictionary of transmitters in the scene
Type
dict (read-only), { “name”, Transmitter}
property
tx_array
Get/set the antenna array used by all transmitters in the scene. Defaults to None.
Type
AntennaArray
property
wavelength
Wavelength [m]
Type
float (read-only)
### sionna.rt.Scene.compute_paths(self, max_depth=3, method='fibonacci', num_samples=1000000, los=True, reflection=True, diffraction=False, scattering=False, scat_keep_prob=0.001, edge_diffraction=False, check_scene=True, scat_random_phases=True, testing=False)
Computes propagation paths
This function computes propagation paths between the antennas of all transmitters and receivers in the current scene. For each propagation path
i
, the corresponding channel coefficient
a_i
and delay
\tau_i
, as well as the angles of departure
(\theta_{\text{T},i}, \varphi_{\text{T},i})
and arrival
(\theta_{\text{R},i}, \varphi_{\text{R},i})
are returned. For more detail, see (26). Different propagation phenomena, such as line-of-sight, reflection, diffraction, and diffuse scattering can be individually enabled/disabled.
If the scene is configured to use synthetic arrays (synthetic_array is True), transmitters and receivers are modelled as if they had a single antenna located at their position. The channel responses for each individual antenna of the arrays are then computed “synthetically” by applying appropriate phase shifts. This reduces the complexity significantly for large arrays. Time evolution of the channel coefficients can be simulated with the help of the function apply_doppler() of the returned Paths object.
The path computation consists of two main steps as shown in the below figure.
For a configured Scene, the function first traces geometric propagation paths using trace_paths(). This step is independent of the RadioMaterial of the scene objects as well as the transmitters’ and receivers’ antenna patterns and orientation, but depends on the selected propagation phenomena, such as reflection, scattering, and diffraction. The traced paths are then converted to EM fields by the function compute_fields(). The resulting Paths object can be used to compute channel impulse responses via cir(). The advantage of separating path tracing and field computation is that one can study the impact of different radio materials by executing compute_fields() multiple times without re-tracing the propagation paths. This can for example speed-up the calibration of scene parameters by several orders of magnitude.
Example
import sionna
from sionna.rt import load_scene, Camera, Transmitter, Receiver, PlanarArray

# Load example scene
scene = load_scene(sionna.rt.scene.munich)

# Configure antenna array for all transmitters
scene.tx_array = PlanarArray(num_rows=8,
                          num_cols=2,
                          vertical_spacing=0.7,
                          horizontal_spacing=0.5,
                          pattern="tr38901",
                          polarization="VH")

# Configure antenna array for all receivers
scene.rx_array = PlanarArray(num_rows=1,
                          num_cols=1,
                          vertical_spacing=0.5,
                          horizontal_spacing=0.5,
                          pattern="dipole",
                          polarization="cross")

# Create transmitter
tx = Transmitter(name="tx",
              position=[8.5,21,27],
              orientation=[0,0,0])
scene.add(tx)

# Create a receiver
rx = Receiver(name="rx",
           position=[45,90,1.5],
           orientation=[0,0,0])
scene.add(rx)

# TX points towards RX
tx.look_at(rx)

# Compute paths
paths = scene.compute_paths()

# Open preview showing paths
scene.preview(paths=paths, resolution=[1000,600])
Input
max_depth (int) – Maximum depth (i.e., number of bounces) allowed for tracing the paths. Defaults to 3.
method (str (“exhaustive”|”fibonacci”)) – Ray tracing method to be used. The “exhaustive” method tests all possible combinations of primitives. This method is not compatible with scattering. The “fibonacci” method uses a shoot-and-bounce approach to find candidate chains of primitives. Initial ray directions are chosen according to a Fibonacci lattice on the unit sphere. This method can be applied to very large scenes. However, there is no guarantee that all possible paths are found. Defaults to “fibonacci”.
num_samples (int) – Number of rays to trace in order to generate candidates with the “fibonacci” method. This number is split equally among the different transmitters (when using synthetic arrays) or transmit antennas (when not using synthetic arrays). This parameter is ignored when using the exhaustive method. Tracing more rays can lead to better precision at the cost of increased memory requirements. Defaults to 1e6.
los (bool) – If set to True, then the LoS paths are computed. Defaults to True.
reflection (bool) – If set to True, then the reflected paths are computed. Defaults to True.
diffraction (bool) – If set to True, then the diffracted paths are computed. Defaults to False.
scattering (bool) – if set to True, then the scattered paths are computed. Only works with the Fibonacci method. Defaults to False.
scat_keep_prob (float) – Probability with which a scattered path is kept. This is helpful to reduce the number of computed scattered paths, which might be prohibitively high in some scenes. Must be in the range (0,1). Defaults to 0.001.
edge_diffraction (bool) – If set to False, only diffraction on wedges, i.e., edges that connect two primitives, is considered. Defaults to False.
check_scene (bool) – If set to True, checks that the scene is well configured before computing the paths. This can add a significant overhead. Defaults to True.
scat_random_phases (bool) – If set to True and if scattering is enabled, random uniform phase shifts are added to the scattered paths. Defaults to True.
testing (bool) – If set to True, then additional data is returned for testing. Defaults to False.
Output
paths : Paths – Simulated paths
### sionna.rt.Scene.trace_paths(self, max_depth=3, method='fibonacci', num_samples=1000000, los=True, reflection=True, diffraction=False, scattering=False, scat_keep_prob=0.001, edge_diffraction=False, check_scene=True)
Computes the trajectories of the paths by shooting rays
The EM fields corresponding to the traced paths are not computed. They can be computed using compute_fields():
traced_paths = scene.trace_paths()
paths = scene.compute_fields(*traced_paths)
Path tracing is independent of the radio materials, antenna patterns, and radio device orientations. Therefore, a set of traced paths could be reused for different values of these quantities, e.g., to calibrate the ray tracer. This can enable significant resource savings as path tracing is typically significantly more resource-intensive than field computation.
Note that compute_paths() does both path tracing and field computation.
Input
max_depth (int) – Maximum depth (i.e., number of interaction with objects in the scene) allowed for tracing the paths. Defaults to 3.
method (str (“exhaustive”|”fibonacci”)) – Method to be used to list candidate paths. The “exhaustive” method tests all possible combination of primitives as paths. This method is not compatible with scattering. The “fibonacci” method uses a shoot-and-bounce approach to find candidate chains of primitives. Initial ray directions are arranged in a Fibonacci lattice on the unit sphere. This method can be applied to very large scenes. However, there is no guarantee that all possible paths are found. Defaults to “fibonacci”.
num_samples (int) – Number of random rays to trace in order to generate candidates. A large sample count may exhaust GPU memory. Defaults to 1e6. Only needed if method is “fibonacci”.
los (bool) – If set to True, then the LoS paths are computed. Defaults to True.
reflection (bool) – If set to True, then the reflected paths are computed. Defaults to True.
diffraction (bool) – If set to True, then the diffracted paths are computed. Defaults to False.
scattering (bool) – If set to True, then the scattered paths are computed. Only works with the Fibonacci method. Defaults to False.
scat_keep_prob (float) – Probability with which to keep scattered paths. This is helpful to reduce the number of scattered paths computed, which might be prohibitively high in some setup. Must be in the range (0,1). Defaults to 0.001.
edge_diffraction (bool) – If set to False, only diffraction on wedges, i.e., edges that connect two primitives, is considered. Defaults to False.
check_scene (bool) – If set to True, checks that the scene is well configured before computing the paths. This can add a significant overhead. Defaults to True.
Output
spec_paths (Paths) – Computed specular paths
diff_paths (Paths) – Computed diffracted paths
scat_paths (Paths) – Computed scattered paths
spec_paths_tmp (PathsTmpData) – Additional data required to compute the EM fields of the specular paths
diff_paths_tmp (PathsTmpData) – Additional data required to compute the EM fields of the diffracted paths
scat_paths_tmp (PathsTmpData) – Additional data required to compute the EM fields of the scattered paths
### sionna.rt.Scene.compute_fields(self, spec_paths, diff_paths, scat_paths, spec_paths_tmp, diff_paths_tmp, scat_paths_tmp, check_scene=True, scat_random_phases=True)
Computes the EM fields corresponding to traced paths
Paths can be traced using trace_paths(). This method can then be used to finalize the paths calculation by computing the corresponding fields:
traced_paths = scene.trace_paths()
paths = scene.compute_fields(*traced_paths)
Paths tracing is independent from the radio materials, antenna patterns, and radio devices orientations. Therefore, a set of traced paths could be reused for different values of these quantities, e.g., to calibrate the ray tracer. This can enable significant resource savings as paths tracing is typically significantly more resource-intensive than field computation.
Note that compute_paths() does both tracing and field computation.
Input
spec_paths (Paths) – Specular paths
diff_paths (Paths) – Diffracted paths
scat_paths (Paths) – Scattered paths
spec_paths_tmp (PathsTmpData) – Additional data required to compute the EM fields of the specular paths
diff_paths_tmp (PathsTmpData) – Additional data required to compute the EM fields of the diffracted paths
scat_paths_tmp (PathsTmpData) – Additional data required to compute the EM fields of the scattered paths
check_scene (bool) – If set to True, checks that the scene is well configured before computing the paths. This can add a significant overhead. Defaults to True.
scat_random_phases (bool) – If set to True and if scattering is enabled, random uniform phase shifts are added to the scattered paths. Defaults to True.
Output
paths (Paths) – Computed paths
